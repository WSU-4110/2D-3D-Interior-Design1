"use strict";
(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // node_modules/type/value/is.js
  var require_is = __commonJS({
    "node_modules/type/value/is.js"(exports, module) {
      "use strict";
      var _undefined = void 0;
      module.exports = function(value) {
        return value !== _undefined && value !== null;
      };
    }
  });

  // node_modules/type/object/is.js
  var require_is2 = __commonJS({
    "node_modules/type/object/is.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var possibleTypes = {
        "object": true,
        "function": true,
        "undefined": true
        /* document.all */
      };
      module.exports = function(value) {
        if (!isValue(value))
          return false;
        return hasOwnProperty.call(possibleTypes, typeof value);
      };
    }
  });

  // node_modules/type/prototype/is.js
  var require_is3 = __commonJS({
    "node_modules/type/prototype/is.js"(exports, module) {
      "use strict";
      var isObject = require_is2();
      module.exports = function(value) {
        if (!isObject(value))
          return false;
        try {
          if (!value.constructor)
            return false;
          return value.constructor.prototype === value;
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/type/function/is.js
  var require_is4 = __commonJS({
    "node_modules/type/function/is.js"(exports, module) {
      "use strict";
      var isPrototype = require_is3();
      module.exports = function(value) {
        if (typeof value !== "function")
          return false;
        if (!hasOwnProperty.call(value, "length"))
          return false;
        try {
          if (typeof value.length !== "number")
            return false;
          if (typeof value.call !== "function")
            return false;
          if (typeof value.apply !== "function")
            return false;
        } catch (error) {
          return false;
        }
        return !isPrototype(value);
      };
    }
  });

  // node_modules/type/plain-function/is.js
  var require_is5 = __commonJS({
    "node_modules/type/plain-function/is.js"(exports, module) {
      "use strict";
      var isFunction = require_is4();
      var classRe = /^\s*class[\s{/}]/;
      var functionToString = Function.prototype.toString;
      module.exports = function(value) {
        if (!isFunction(value))
          return false;
        if (classRe.test(functionToString.call(value)))
          return false;
        return true;
      };
    }
  });

  // node_modules/es5-ext/object/assign/is-implemented.js
  var require_is_implemented = __commonJS({
    "node_modules/es5-ext/object/assign/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var assign = Object.assign, obj;
        if (typeof assign !== "function")
          return false;
        obj = { foo: "raz" };
        assign(obj, { bar: "dwa" }, { trzy: "trzy" });
        return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
      };
    }
  });

  // node_modules/es5-ext/object/keys/is-implemented.js
  var require_is_implemented2 = __commonJS({
    "node_modules/es5-ext/object/keys/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        try {
          Object.keys("primitive");
          return true;
        } catch (e) {
          return false;
        }
      };
    }
  });

  // node_modules/es5-ext/function/noop.js
  var require_noop = __commonJS({
    "node_modules/es5-ext/function/noop.js"(exports, module) {
      "use strict";
      module.exports = function() {
      };
    }
  });

  // node_modules/es5-ext/object/is-value.js
  var require_is_value = __commonJS({
    "node_modules/es5-ext/object/is-value.js"(exports, module) {
      "use strict";
      var _undefined = require_noop()();
      module.exports = function(val) {
        return val !== _undefined && val !== null;
      };
    }
  });

  // node_modules/es5-ext/object/keys/shim.js
  var require_shim = __commonJS({
    "node_modules/es5-ext/object/keys/shim.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var keys = Object.keys;
      module.exports = function(object) {
        return keys(isValue(object) ? Object(object) : object);
      };
    }
  });

  // node_modules/es5-ext/object/keys/index.js
  var require_keys = __commonJS({
    "node_modules/es5-ext/object/keys/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented2()() ? Object.keys : require_shim();
    }
  });

  // node_modules/es5-ext/object/valid-value.js
  var require_valid_value = __commonJS({
    "node_modules/es5-ext/object/valid-value.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      module.exports = function(value) {
        if (!isValue(value))
          throw new TypeError("Cannot use null or undefined");
        return value;
      };
    }
  });

  // node_modules/es5-ext/object/assign/shim.js
  var require_shim2 = __commonJS({
    "node_modules/es5-ext/object/assign/shim.js"(exports, module) {
      "use strict";
      var keys = require_keys();
      var value = require_valid_value();
      var max = Math.max;
      module.exports = function(dest, src) {
        var error, i, length = max(arguments.length, 2), assign;
        dest = Object(value(dest));
        assign = function(key) {
          try {
            dest[key] = src[key];
          } catch (e) {
            if (!error)
              error = e;
          }
        };
        for (i = 1; i < length; ++i) {
          src = arguments[i];
          keys(src).forEach(assign);
        }
        if (error !== void 0)
          throw error;
        return dest;
      };
    }
  });

  // node_modules/es5-ext/object/assign/index.js
  var require_assign = __commonJS({
    "node_modules/es5-ext/object/assign/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented()() ? Object.assign : require_shim2();
    }
  });

  // node_modules/es5-ext/object/normalize-options.js
  var require_normalize_options = __commonJS({
    "node_modules/es5-ext/object/normalize-options.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var forEach = Array.prototype.forEach;
      var create = Object.create;
      var process2 = function(src, obj) {
        var key;
        for (key in src)
          obj[key] = src[key];
      };
      module.exports = function(opts1) {
        var result = create(null);
        forEach.call(arguments, function(options) {
          if (!isValue(options))
            return;
          process2(Object(options), result);
        });
        return result;
      };
    }
  });

  // node_modules/es5-ext/string/#/contains/is-implemented.js
  var require_is_implemented3 = __commonJS({
    "node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module) {
      "use strict";
      var str = "razdwatrzy";
      module.exports = function() {
        if (typeof str.contains !== "function")
          return false;
        return str.contains("dwa") === true && str.contains("foo") === false;
      };
    }
  });

  // node_modules/es5-ext/string/#/contains/shim.js
  var require_shim3 = __commonJS({
    "node_modules/es5-ext/string/#/contains/shim.js"(exports, module) {
      "use strict";
      var indexOf = String.prototype.indexOf;
      module.exports = function(searchString) {
        return indexOf.call(this, searchString, arguments[1]) > -1;
      };
    }
  });

  // node_modules/es5-ext/string/#/contains/index.js
  var require_contains = __commonJS({
    "node_modules/es5-ext/string/#/contains/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented3()() ? String.prototype.contains : require_shim3();
    }
  });

  // node_modules/d/index.js
  var require_d = __commonJS({
    "node_modules/d/index.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var isPlainFunction = require_is5();
      var assign = require_assign();
      var normalizeOpts = require_normalize_options();
      var contains = require_contains();
      var d = module.exports = function(dscr, value) {
        var c, e, w, options, desc;
        if (arguments.length < 2 || typeof dscr !== "string") {
          options = value;
          value = dscr;
          dscr = null;
        } else {
          options = arguments[2];
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
          w = contains.call(dscr, "w");
        } else {
          c = w = true;
          e = false;
        }
        desc = { value, configurable: c, enumerable: e, writable: w };
        return !options ? desc : assign(normalizeOpts(options), desc);
      };
      d.gs = function(dscr, get, set) {
        var c, e, options, desc;
        if (typeof dscr !== "string") {
          options = set;
          set = get;
          get = dscr;
          dscr = null;
        } else {
          options = arguments[3];
        }
        if (!isValue(get)) {
          get = void 0;
        } else if (!isPlainFunction(get)) {
          options = get;
          get = set = void 0;
        } else if (!isValue(set)) {
          set = void 0;
        } else if (!isPlainFunction(set)) {
          options = set;
          set = void 0;
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
        } else {
          c = true;
          e = false;
        }
        desc = { get, set, configurable: c, enumerable: e };
        return !options ? desc : assign(normalizeOpts(options), desc);
      };
    }
  });

  // node_modules/es5-ext/object/valid-callable.js
  var require_valid_callable = __commonJS({
    "node_modules/es5-ext/object/valid-callable.js"(exports, module) {
      "use strict";
      module.exports = function(fn) {
        if (typeof fn !== "function")
          throw new TypeError(fn + " is not a function");
        return fn;
      };
    }
  });

  // node_modules/event-emitter/index.js
  var require_event_emitter = __commonJS({
    "node_modules/event-emitter/index.js"(exports, module) {
      "use strict";
      var d = require_d();
      var callable = require_valid_callable();
      var apply = Function.prototype.apply;
      var call = Function.prototype.call;
      var create = Object.create;
      var defineProperty = Object.defineProperty;
      var defineProperties = Object.defineProperties;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var descriptor = { configurable: true, enumerable: false, writable: true };
      var on;
      var once;
      var off;
      var emit;
      var methods;
      var descriptors;
      var base;
      on = function(type, listener) {
        var data;
        callable(listener);
        if (!hasOwnProperty2.call(this, "__ee__")) {
          data = descriptor.value = create(null);
          defineProperty(this, "__ee__", descriptor);
          descriptor.value = null;
        } else {
          data = this.__ee__;
        }
        if (!data[type])
          data[type] = listener;
        else if (typeof data[type] === "object")
          data[type].push(listener);
        else
          data[type] = [data[type], listener];
        return this;
      };
      once = function(type, listener) {
        var once2, self2;
        callable(listener);
        self2 = this;
        on.call(this, type, once2 = function() {
          off.call(self2, type, once2);
          apply.call(listener, this, arguments);
        });
        once2.__eeOnceListener__ = listener;
        return this;
      };
      off = function(type, listener) {
        var data, listeners, candidate, i;
        callable(listener);
        if (!hasOwnProperty2.call(this, "__ee__"))
          return this;
        data = this.__ee__;
        if (!data[type])
          return this;
        listeners = data[type];
        if (typeof listeners === "object") {
          for (i = 0; candidate = listeners[i]; ++i) {
            if (candidate === listener || candidate.__eeOnceListener__ === listener) {
              if (listeners.length === 2)
                data[type] = listeners[i ? 0 : 1];
              else
                listeners.splice(i, 1);
            }
          }
        } else {
          if (listeners === listener || listeners.__eeOnceListener__ === listener) {
            delete data[type];
          }
        }
        return this;
      };
      emit = function(type) {
        var i, l, listener, listeners, args;
        if (!hasOwnProperty2.call(this, "__ee__"))
          return;
        listeners = this.__ee__[type];
        if (!listeners)
          return;
        if (typeof listeners === "object") {
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i)
            args[i - 1] = arguments[i];
          listeners = listeners.slice();
          for (i = 0; listener = listeners[i]; ++i) {
            apply.call(listener, this, args);
          }
        } else {
          switch (arguments.length) {
            case 1:
              call.call(listeners, this);
              break;
            case 2:
              call.call(listeners, this, arguments[1]);
              break;
            case 3:
              call.call(listeners, this, arguments[1], arguments[2]);
              break;
            default:
              l = arguments.length;
              args = new Array(l - 1);
              for (i = 1; i < l; ++i) {
                args[i - 1] = arguments[i];
              }
              apply.call(listeners, this, args);
          }
        }
      };
      methods = {
        on,
        once,
        off,
        emit
      };
      descriptors = {
        on: d(on),
        once: d(once),
        off: d(off),
        emit: d(emit)
      };
      base = defineProperties({}, descriptors);
      module.exports = exports = function(o) {
        return o == null ? create(base) : defineProperties(Object(o), descriptors);
      };
      exports.methods = methods;
    }
  });

  // node_modules/@sinonjs/commons/lib/global.js
  var require_global = __commonJS({
    "node_modules/@sinonjs/commons/lib/global.js"(exports, module) {
      "use strict";
      var globalObject;
      if (typeof global !== "undefined") {
        globalObject = global;
      } else if (typeof window !== "undefined") {
        globalObject = window;
      } else {
        globalObject = self;
      }
      module.exports = globalObject;
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/throws-on-proto.js
  var require_throws_on_proto = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/throws-on-proto.js"(exports, module) {
      "use strict";
      var throwsOnProto;
      try {
        const object = {};
        object.__proto__;
        throwsOnProto = false;
      } catch (_) {
        throwsOnProto = true;
      }
      module.exports = throwsOnProto;
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js
  var require_copy_prototype_methods = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/copy-prototype-methods.js"(exports, module) {
      "use strict";
      var call = Function.call;
      var throwsOnProto = require_throws_on_proto();
      var disallowedProperties = [
        // ignore size because it throws from Map
        "size",
        "caller",
        "callee",
        "arguments"
      ];
      if (throwsOnProto) {
        disallowedProperties.push("__proto__");
      }
      module.exports = function copyPrototypeMethods(prototype) {
        return Object.getOwnPropertyNames(prototype).reduce(
          function(result, name) {
            if (disallowedProperties.includes(name)) {
              return result;
            }
            if (typeof prototype[name] !== "function") {
              return result;
            }
            result[name] = call.bind(prototype[name]);
            return result;
          },
          /* @__PURE__ */ Object.create(null)
        );
      };
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/array.js
  var require_array = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/array.js"(exports, module) {
      "use strict";
      var copyPrototype = require_copy_prototype_methods();
      module.exports = copyPrototype(Array.prototype);
    }
  });

  // node_modules/@sinonjs/commons/lib/called-in-order.js
  var require_called_in_order = __commonJS({
    "node_modules/@sinonjs/commons/lib/called-in-order.js"(exports, module) {
      "use strict";
      var every = require_array().every;
      function hasCallsLeft(callMap, spy) {
        if (callMap[spy.id] === void 0) {
          callMap[spy.id] = 0;
        }
        return callMap[spy.id] < spy.callCount;
      }
      function checkAdjacentCalls(callMap, spy, index, spies) {
        var calledBeforeNext = true;
        if (index !== spies.length - 1) {
          calledBeforeNext = spy.calledBefore(spies[index + 1]);
        }
        if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
          callMap[spy.id] += 1;
          return true;
        }
        return false;
      }
      function calledInOrder(spies) {
        var callMap = {};
        var _spies = arguments.length > 1 ? arguments : spies;
        return every(_spies, checkAdjacentCalls.bind(null, callMap));
      }
      module.exports = calledInOrder;
    }
  });

  // node_modules/@sinonjs/commons/lib/function-name.js
  var require_function_name = __commonJS({
    "node_modules/@sinonjs/commons/lib/function-name.js"(exports, module) {
      "use strict";
      module.exports = function functionName(func) {
        if (!func) {
          return "";
        }
        try {
          return func.displayName || func.name || // Use function decomposition as a last resort to get function
          // name. Does not rely on function decomposition to work - if it
          // doesn't debugging will be slightly less informative
          // (i.e. toString will say 'spy' rather than 'myFunc').
          (String(func).match(/function ([^\s(]+)/) || [])[1];
        } catch (e) {
          return "";
        }
      };
    }
  });

  // node_modules/@sinonjs/commons/lib/class-name.js
  var require_class_name = __commonJS({
    "node_modules/@sinonjs/commons/lib/class-name.js"(exports, module) {
      "use strict";
      var functionName = require_function_name();
      function className(value) {
        return value.constructor && value.constructor.name || // The next branch is for IE11 support only:
        // Because the name property is not set on the prototype
        // of the Function object, we finally try to grab the
        // name from its definition. This will never be reached
        // in node, so we are not able to test this properly.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
        typeof value.constructor === "function" && /* istanbul ignore next */
        functionName(value.constructor) || null;
      }
      module.exports = className;
    }
  });

  // node_modules/@sinonjs/commons/lib/deprecated.js
  var require_deprecated = __commonJS({
    "node_modules/@sinonjs/commons/lib/deprecated.js"(exports) {
      "use strict";
      exports.wrap = function(func, msg) {
        var wrapped = function() {
          exports.printWarning(msg);
          return func.apply(this, arguments);
        };
        if (func.prototype) {
          wrapped.prototype = func.prototype;
        }
        return wrapped;
      };
      exports.defaultMsg = function(packageName, funcName) {
        return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;
      };
      exports.printWarning = function(msg) {
        if (typeof process === "object" && process.emitWarning) {
          process.emitWarning(msg);
        } else if (console.info) {
          console.info(msg);
        } else {
          console.log(msg);
        }
      };
    }
  });

  // node_modules/@sinonjs/commons/lib/every.js
  var require_every = __commonJS({
    "node_modules/@sinonjs/commons/lib/every.js"(exports, module) {
      "use strict";
      module.exports = function every(obj, fn) {
        var pass = true;
        try {
          obj.forEach(function() {
            if (!fn.apply(this, arguments)) {
              throw new Error();
            }
          });
        } catch (e) {
          pass = false;
        }
        return pass;
      };
    }
  });

  // node_modules/@sinonjs/commons/lib/order-by-first-call.js
  var require_order_by_first_call = __commonJS({
    "node_modules/@sinonjs/commons/lib/order-by-first-call.js"(exports, module) {
      "use strict";
      var sort = require_array().sort;
      var slice = require_array().slice;
      function comparator(a, b) {
        var aCall = a.getCall(0);
        var bCall = b.getCall(0);
        var aId = aCall && aCall.callId || -1;
        var bId = bCall && bCall.callId || -1;
        return aId < bId ? -1 : 1;
      }
      function orderByFirstCall(spies) {
        return sort(slice(spies), comparator);
      }
      module.exports = orderByFirstCall;
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/function.js
  var require_function = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/function.js"(exports, module) {
      "use strict";
      var copyPrototype = require_copy_prototype_methods();
      module.exports = copyPrototype(Function.prototype);
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/map.js
  var require_map = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/map.js"(exports, module) {
      "use strict";
      var copyPrototype = require_copy_prototype_methods();
      module.exports = copyPrototype(Map.prototype);
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/object.js
  var require_object = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/object.js"(exports, module) {
      "use strict";
      var copyPrototype = require_copy_prototype_methods();
      module.exports = copyPrototype(Object.prototype);
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/set.js
  var require_set = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/set.js"(exports, module) {
      "use strict";
      var copyPrototype = require_copy_prototype_methods();
      module.exports = copyPrototype(Set.prototype);
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/string.js
  var require_string = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/string.js"(exports, module) {
      "use strict";
      var copyPrototype = require_copy_prototype_methods();
      module.exports = copyPrototype(String.prototype);
    }
  });

  // node_modules/@sinonjs/commons/lib/prototypes/index.js
  var require_prototypes = __commonJS({
    "node_modules/@sinonjs/commons/lib/prototypes/index.js"(exports, module) {
      "use strict";
      module.exports = {
        array: require_array(),
        function: require_function(),
        map: require_map(),
        object: require_object(),
        set: require_set(),
        string: require_string()
      };
    }
  });

  // node_modules/type-detect/type-detect.js
  var require_type_detect = __commonJS({
    "node_modules/type-detect/type-detect.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.typeDetect = factory();
      })(exports, function() {
        "use strict";
        var promiseExists = typeof Promise === "function";
        var globalObject = typeof self === "object" ? self : global;
        var symbolExists = typeof Symbol !== "undefined";
        var mapExists = typeof Map !== "undefined";
        var setExists = typeof Set !== "undefined";
        var weakMapExists = typeof WeakMap !== "undefined";
        var weakSetExists = typeof WeakSet !== "undefined";
        var dataViewExists = typeof DataView !== "undefined";
        var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
        var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
        var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
        var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
        var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
        var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
        var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
        var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
        var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
        var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
        var toStringLeftSliceLength = 8;
        var toStringRightSliceLength = -1;
        function typeDetect(obj) {
          var typeofObj = typeof obj;
          if (typeofObj !== "object") {
            return typeofObj;
          }
          if (obj === null) {
            return "null";
          }
          if (obj === globalObject) {
            return "global";
          }
          if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
            return "Array";
          }
          if (typeof window === "object" && window !== null) {
            if (typeof window.location === "object" && obj === window.location) {
              return "Location";
            }
            if (typeof window.document === "object" && obj === window.document) {
              return "Document";
            }
            if (typeof window.navigator === "object") {
              if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) {
                return "MimeTypeArray";
              }
              if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) {
                return "PluginArray";
              }
            }
            if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
              if (obj.tagName === "BLOCKQUOTE") {
                return "HTMLQuoteElement";
              }
              if (obj.tagName === "TD") {
                return "HTMLTableDataCellElement";
              }
              if (obj.tagName === "TH") {
                return "HTMLTableHeaderCellElement";
              }
            }
          }
          var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
          if (typeof stringTag === "string") {
            return stringTag;
          }
          var objPrototype = Object.getPrototypeOf(obj);
          if (objPrototype === RegExp.prototype) {
            return "RegExp";
          }
          if (objPrototype === Date.prototype) {
            return "Date";
          }
          if (promiseExists && objPrototype === Promise.prototype) {
            return "Promise";
          }
          if (setExists && objPrototype === Set.prototype) {
            return "Set";
          }
          if (mapExists && objPrototype === Map.prototype) {
            return "Map";
          }
          if (weakSetExists && objPrototype === WeakSet.prototype) {
            return "WeakSet";
          }
          if (weakMapExists && objPrototype === WeakMap.prototype) {
            return "WeakMap";
          }
          if (dataViewExists && objPrototype === DataView.prototype) {
            return "DataView";
          }
          if (mapExists && objPrototype === mapIteratorPrototype) {
            return "Map Iterator";
          }
          if (setExists && objPrototype === setIteratorPrototype) {
            return "Set Iterator";
          }
          if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
            return "Array Iterator";
          }
          if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
            return "String Iterator";
          }
          if (objPrototype === null) {
            return "Object";
          }
          return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
        }
        return typeDetect;
      });
    }
  });

  // node_modules/@sinonjs/commons/lib/type-of.js
  var require_type_of = __commonJS({
    "node_modules/@sinonjs/commons/lib/type-of.js"(exports, module) {
      "use strict";
      var type = require_type_detect();
      module.exports = function typeOf(value) {
        return type(value).toLowerCase();
      };
    }
  });

  // node_modules/@sinonjs/commons/lib/value-to-string.js
  var require_value_to_string = __commonJS({
    "node_modules/@sinonjs/commons/lib/value-to-string.js"(exports, module) {
      "use strict";
      function valueToString(value) {
        if (value && value.toString) {
          return value.toString();
        }
        return String(value);
      }
      module.exports = valueToString;
    }
  });

  // node_modules/@sinonjs/commons/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@sinonjs/commons/lib/index.js"(exports, module) {
      "use strict";
      module.exports = {
        global: require_global(),
        calledInOrder: require_called_in_order(),
        className: require_class_name(),
        deprecated: require_deprecated(),
        every: require_every(),
        functionName: require_function_name(),
        orderByFirstCall: require_order_by_first_call(),
        prototypes: require_prototypes(),
        typeOf: require_type_of(),
        valueToString: require_value_to_string()
      };
    }
  });

  // lib/assert-arg-num.js
  var require_assert_arg_num = __commonJS({
    "lib/assert-arg-num.js"(exports, module) {
      "use strict";
      function assertArgNum(fail, name, args, num) {
        if (args.length >= num) {
          return true;
        }
        fail(`[${name}] Expected to receive at least ${num} argument(s)`);
        return false;
      }
      module.exports = assertArgNum;
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var toStr = Object.prototype.toString;
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return toStr.call(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value) !== "[object Array]" && toStr.call(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var generatorFunc = getGeneratorFunc();
      var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/foreach/index.js
  var require_foreach = __commonJS({
    "node_modules/foreach/index.js"(exports, module) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      module.exports = function forEach(obj, fn, ctx) {
        if (toString.call(fn) !== "[object Function]") {
          throw new TypeError("iterator must be a function");
        }
        var l = obj.length;
        if (l === +l) {
          for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
          }
        } else {
          for (var k in obj) {
            if (hasOwn.call(obj, k)) {
              fn.call(ctx, obj[k], k, obj);
            }
          }
        }
      };
    }
  });

  // node_modules/array-filter/index.js
  var require_array_filter = __commonJS({
    "node_modules/array-filter/index.js"(exports, module) {
      module.exports = function(arr, fn, self2) {
        if (arr.filter)
          return arr.filter(fn, self2);
        if (void 0 === arr || null === arr)
          throw new TypeError();
        if ("function" != typeof fn)
          throw new TypeError();
        var ret = [];
        for (var i = 0; i < arr.length; i++) {
          if (!hasOwn.call(arr, i))
            continue;
          var val = arr[i];
          if (fn.call(self2, val, i, arr))
            ret.push(val);
        }
        return ret;
      };
      var hasOwn = Object.prototype.hasOwnProperty;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      var filter = require_array_filter();
      module.exports = function availableTypedArrays() {
        return filter([
          "BigInt64Array",
          "BigUint64Array",
          "Float32Array",
          "Float64Array",
          "Int16Array",
          "Int32Array",
          "Int8Array",
          "Uint16Array",
          "Uint32Array",
          "Uint8Array",
          "Uint8ClampedArray"
        ], function(typedArray) {
          return typeof global[typedArray] === "function";
        });
      };
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = global.Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/es-abstract/GetIntrinsic.js
  var require_GetIntrinsic = __commonJS({
    "node_modules/es-abstract/GetIntrinsic.js"(exports, module) {
      "use strict";
      var undefined2;
      var $TypeError = TypeError;
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var generator;
      var generatorFunction = generator ? getProto(generator) : undefined2;
      var asyncFn;
      var asyncFunction = asyncFn ? asyncFn.constructor : undefined2;
      var asyncGen;
      var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined2;
      var asyncGenIterator = asyncGen ? asyncGen() : undefined2;
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer.prototype,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%ArrayPrototype%": Array.prototype,
        "%ArrayProto_entries%": Array.prototype.entries,
        "%ArrayProto_forEach%": Array.prototype.forEach,
        "%ArrayProto_keys%": Array.prototype.keys,
        "%ArrayProto_values%": Array.prototype.values,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": asyncFunction,
        "%AsyncFunctionPrototype%": asyncFunction ? asyncFunction.prototype : undefined2,
        "%AsyncGenerator%": asyncGen ? getProto(asyncGenIterator) : undefined2,
        "%AsyncGeneratorFunction%": asyncGenFunction,
        "%AsyncGeneratorPrototype%": asyncGenFunction ? asyncGenFunction.prototype : undefined2,
        "%AsyncIteratorPrototype%": asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined2,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%Boolean%": Boolean,
        "%BooleanPrototype%": Boolean.prototype,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%DataViewPrototype%": typeof DataView === "undefined" ? undefined2 : DataView.prototype,
        "%Date%": Date,
        "%DatePrototype%": Date.prototype,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%ErrorPrototype%": Error.prototype,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%EvalErrorPrototype%": EvalError.prototype,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined2 : Float32Array.prototype,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined2 : Float64Array.prototype,
        "%Function%": Function,
        "%FunctionPrototype%": Function.prototype,
        "%Generator%": generator ? getProto(generator()) : undefined2,
        "%GeneratorFunction%": generatorFunction,
        "%GeneratorPrototype%": generatorFunction ? generatorFunction.prototype : undefined2,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined2 : Int8Array.prototype,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined2 : Int8Array.prototype,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined2 : Int32Array.prototype,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%MapPrototype%": typeof Map === "undefined" ? undefined2 : Map.prototype,
        "%Math%": Math,
        "%Number%": Number,
        "%NumberPrototype%": Number.prototype,
        "%Object%": Object,
        "%ObjectPrototype%": Object.prototype,
        "%ObjProto_toString%": Object.prototype.toString,
        "%ObjProto_valueOf%": Object.prototype.valueOf,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%PromisePrototype%": typeof Promise === "undefined" ? undefined2 : Promise.prototype,
        "%PromiseProto_then%": typeof Promise === "undefined" ? undefined2 : Promise.prototype.then,
        "%Promise_all%": typeof Promise === "undefined" ? undefined2 : Promise.all,
        "%Promise_reject%": typeof Promise === "undefined" ? undefined2 : Promise.reject,
        "%Promise_resolve%": typeof Promise === "undefined" ? undefined2 : Promise.resolve,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%RangeErrorPrototype%": RangeError.prototype,
        "%ReferenceError%": ReferenceError,
        "%ReferenceErrorPrototype%": ReferenceError.prototype,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%RegExpPrototype%": RegExp.prototype,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SetPrototype%": typeof Set === "undefined" ? undefined2 : Set.prototype,
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer.prototype,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%StringPrototype%": String.prototype,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SymbolPrototype%": hasSymbols ? Symbol.prototype : undefined2,
        "%SyntaxError%": SyntaxError,
        "%SyntaxErrorPrototype%": SyntaxError.prototype,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypedArrayPrototype%": TypedArray ? TypedArray.prototype : undefined2,
        "%TypeError%": $TypeError,
        "%TypeErrorPrototype%": $TypeError.prototype,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array.prototype,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray.prototype,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array.prototype,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array.prototype,
        "%URIError%": URIError,
        "%URIErrorPrototype%": URIError.prototype,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined2 : WeakMap.prototype,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
        "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined2 : WeakSet.prototype
      };
      var bind = require_function_bind();
      var $replace = bind.call(Function.call, String.prototype.replace);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        if (!(name in INTRINSICS)) {
          throw new SyntaxError("intrinsic " + name + " does not exist!");
        }
        if (typeof INTRINSICS[name] === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return INTRINSICS[name];
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new TypeError('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var value = getBaseIntrinsic("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
        for (var i = 1; i < parts.length; i += 1) {
          if (value != null) {
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, parts[i]);
              if (!allowMissing && !(parts[i] in value)) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              value = desc ? desc.get || desc.value : value[parts[i]];
            } else {
              value = value[parts[i]];
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/es-abstract/helpers/callBind.js
  var require_callBind = __commonJS({
    "node_modules/es-abstract/helpers/callBind.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_GetIntrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      module.exports = function callBind() {
        return $reflectApply(bind, $call, arguments);
      };
      module.exports.apply = function applyBind() {
        return $reflectApply(bind, $apply, arguments);
      };
    }
  });

  // node_modules/es-abstract/helpers/callBound.js
  var require_callBound = __commonJS({
    "node_modules/es-abstract/helpers/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_GetIntrinsic();
      var callBind = require_callBind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.")) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
  var require_getOwnPropertyDescriptor = __commonJS({
    "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_GetIntrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%");
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_foreach();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasSymbols = require_has_symbols()();
      var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new global[typedArray]();
          if (!(Symbol.toStringTag in arr)) {
            throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
          }
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e) {
            }
          }
        });
        return anyTrue;
      };
      module.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_foreach();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasSymbols = require_has_symbols()();
      var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof global[typedArray] === "function") {
            var arr = new global[typedArray]();
            if (!(Symbol.toStringTag in arr)) {
              throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
            }
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name = getter.call(value);
              if (name === typedArray) {
                foundName = name;
              }
            } catch (e) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty2(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty2(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // lib/define-assertion/format.js
  var require_format = __commonJS({
    "lib/define-assertion/format.js"(exports, module) {
      "use strict";
      var inspect = require_util().inspect;
      function format(object) {
        if (object instanceof Error) {
          return object.name;
        }
        return inspect(object);
      }
      module.exports = format;
    }
  });

  // lib/define-assertion/interpolate-pos-arg.js
  var require_interpolate_pos_arg = __commonJS({
    "lib/define-assertion/interpolate-pos-arg.js"(exports, module) {
      "use strict";
      var format = require_format();
      function interpolatePosArg(message, values) {
        return message.replace(/\${([0-9]+)}/gi, function(match, num) {
          var index = parseInt(num, 10);
          var value = values[index];
          return format(value);
        });
      }
      module.exports = interpolatePosArg;
    }
  });

  // lib/define-assertion/interpolate-properties.js
  var require_interpolate_properties = __commonJS({
    "lib/define-assertion/interpolate-properties.js"(exports, module) {
      "use strict";
      var hasOwnProperty2 = require_lib().prototypes.object.hasOwnProperty;
      var format = require_format();
      function prepareMessage(message) {
        if (!message) {
          return "";
        }
        return message + (/[.:!?]$/.test(message) ? " " : ": ");
      }
      function interpolateProperties(referee, message, properties) {
        return message.replace(
          /\${(\.\.\.|!)?([a-z]+)}/gi,
          function(match, prefix, name) {
            if (!hasOwnProperty2(properties, name)) {
              return match;
            }
            var value = properties[name];
            if (prefix === "!") {
              return value;
            }
            if (prefix === "..." && Array.isArray(value)) {
              return value.map(format).join(", ");
            }
            if (name === "customMessage") {
              return prepareMessage(value);
            }
            return format(value);
          }
        );
      }
      module.exports = interpolateProperties;
    }
  });

  // lib/define-assertion/get-message.js
  var require_get_message = __commonJS({
    "lib/define-assertion/get-message.js"(exports, module) {
      "use strict";
      function getMessage(referee, type, name, msg) {
        switch (typeof referee[type][name][msg]) {
          case "function":
            return referee[type][name][msg]();
          case "string":
            return referee[type][name][msg] || msg;
          default:
            return msg;
        }
      }
      module.exports = getMessage;
    }
  });

  // lib/define-assertion/index.js
  var require_define_assertion = __commonJS({
    "lib/define-assertion/index.js"(exports, module) {
      "use strict";
      var slice = require_lib().prototypes.array.slice;
      var assertArgNum = require_assert_arg_num();
      var interpolatePosArg = require_interpolate_pos_arg();
      var interpolateProperties = require_interpolate_properties();
      var getMessage = require_get_message();
      function createAssertion(referee, type, name, func, minArgs, messageValues) {
        var assertion = function() {
          var fullName = `${type}.${name}`;
          var failed = false;
          assertArgNum(referee.fail, fullName, arguments, minArgs);
          var args = slice(arguments, 0);
          var namedValues = {};
          var ctx = {
            fail: function(msg) {
              if (typeof messageValues === "function") {
                namedValues = messageValues.apply(this, args);
              }
              failed = true;
              delete this.fail;
              var message = getMessage(referee, type, name, msg);
              message = interpolatePosArg(message, args);
              message = interpolateProperties(referee, message, this);
              message = interpolateProperties(referee, message, namedValues);
              var operator = `${type}.${name}`;
              var errorProperties = {
                operator
              };
              if (type === "assert") {
                if (namedValues.hasOwnProperty("actual") && namedValues.hasOwnProperty("expected")) {
                  errorProperties.actual = namedValues.actual;
                  errorProperties.expected = namedValues.expected;
                }
              }
              referee.fail(`[${operator}] ${message}`, errorProperties);
              return false;
            }
          };
          var result = func.apply(ctx, arguments);
          if (typeof Promise === "function" && result instanceof Promise) {
            return result.then(function() {
              referee.pass(["pass", fullName].concat(args));
            });
          }
          if (!result && !failed) {
            ctx.fail("message");
          }
          if (!failed) {
            referee.pass(["pass", fullName].concat(args));
          }
          return void 0;
        };
        return assertion;
      }
      function defineAssertion(referee, type, name, func, minArgs, messageValues) {
        referee[type][name] = function() {
          var assertion = createAssertion(
            referee,
            type,
            name,
            func,
            minArgs,
            messageValues
          );
          return assertion.apply(null, arguments);
        };
      }
      module.exports = defineAssertion;
    }
  });

  // lib/create-add.js
  var require_create_add = __commonJS({
    "lib/create-add.js"(exports, module) {
      "use strict";
      var defineAssertion = require_define_assertion();
      var validFunctionName = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
      function verifyArguments(name, options) {
        if (typeof name !== "string" || !validFunctionName.test(name)) {
          throw new TypeError(
            `'name' argument must be a non-empty string matching ${validFunctionName.toString()}`
          );
        }
        if (typeof options !== "object" || Object.keys(options).length === 0) {
          throw new TypeError("'options' argument must be a non-empty object");
        }
        if (typeof options.assert !== "function" || options.assert.length === 0) {
          throw new TypeError(
            "'assert' option must be a Function, taking at least one argument"
          );
        }
        if (typeof options.refute !== "undefined" && (typeof options.refute !== "function" || options.refute.length === 0)) {
          throw new TypeError(
            "'refute' option must be a Function, taking at least one argument"
          );
        }
        ["assertMessage", "refuteMessage"].forEach((m) => {
          if (!isValidMessageOption(options[m])) {
            throw new TypeError(
              `'${m}' option must be a non-empty String or Function`
            );
          }
        });
      }
      function isValidMessageOption(message) {
        if (typeof message === "undefined") {
          return true;
        }
        if (typeof message === "function") {
          return true;
        }
        if (typeof message === "string" && message.length > 0) {
          return true;
        }
        return false;
      }
      function createAdd(referee) {
        function add(name, options) {
          verifyArguments(name, options);
          var refuteArgs = options.refute ? options.refute.length : options.assert.length;
          if (!options.refute) {
            options.refute = function() {
              return !options.assert.apply(this, arguments);
            };
          }
          defineAssertion(
            referee,
            "assert",
            name,
            options.assert,
            options.assert.length,
            options.values
          );
          defineAssertion(
            referee,
            "refute",
            name,
            options.refute,
            refuteArgs,
            options.values
          );
          referee.assert[name].message = options.assertMessage;
          referee.refute[name].message = options.refuteMessage;
          if (!options.expectation) {
            return;
          }
          referee.assert[name].expectationName = options.expectation;
          referee.refute[name].expectationName = options.expectation;
        }
        return add;
      }
      module.exports = createAdd;
    }
  });

  // lib/create-assert.js
  var require_create_assert = __commonJS({
    "lib/create-assert.js"(exports, module) {
      "use strict";
      var assertArgNum = require_assert_arg_num();
      function createAssert(referee) {
        function assert(actual, message) {
          assertArgNum(referee.fail, "assert", arguments, 1);
          if (!actual) {
            referee.fail(
              message || `[assert] Expected ${String(actual)} to be truthy`
            );
            return;
          }
          referee.emit("pass", "assert", message || "", actual);
        }
        assert.toString = function() {
          return "referee.assert()";
        };
        return assert;
      }
      module.exports = createAssert;
    }
  });

  // lib/create-refute.js
  var require_create_refute = __commonJS({
    "lib/create-refute.js"(exports, module) {
      "use strict";
      var assertArgNum = require_assert_arg_num();
      function createRefute(referee) {
        function refute(actual, message) {
          assertArgNum(referee.fail, "refute", arguments, 1);
          if (actual) {
            referee.fail(
              message || `[refute] Expected ${String(actual)} to be falsy`
            );
            return;
          }
          referee.emit("pass", "refute", message || "", actual);
        }
        refute.toString = function() {
          return "referee.refute()";
        };
        return refute;
      }
      module.exports = createRefute;
    }
  });

  // lib/expect.js
  var require_expect = __commonJS({
    "lib/expect.js"(exports, module) {
      "use strict";
      function expect(actual) {
        var expectation = Object.assign(Object.create(expect.expectation), {
          actual,
          assertMode: true
        });
        expectation.not = Object.assign(Object.create(expectation), {
          assertMode: false
        });
        return expectation;
      }
      expect.expectation = /* @__PURE__ */ Object.create(null);
      expect.wrapAssertion = function wrapAssertion(assertion, expectation, referee) {
        expect.expectation[expectation] = function() {
          var args = [this.actual].concat(Array.from(arguments));
          var type = this.assertMode ? "assert" : "refute";
          var callFunc;
          if (assertion === "assert") {
            callFunc = this.assertMode ? referee.assert : referee.refute;
          } else if (assertion === "refute") {
            callFunc = this.assertMode ? referee.refute : referee.assert;
          } else {
            callFunc = referee[type][assertion];
          }
          try {
            return callFunc.apply(referee.expect, args);
          } catch (e) {
            e.message = e.message.replace(
              `[${type}.${assertion}]`,
              `[expect.${this.assertMode ? "" : "not."}${expectation}]`
            );
            throw e;
          }
        };
      };
      expect.init = function init(referee) {
        Object.keys(referee.assert).forEach(function(name) {
          var expectationName = referee.assert[name].expectationName;
          if (expectationName) {
            expect.wrapAssertion(name, expectationName, referee);
          }
        });
        expect.wrapAssertion("assert", "toBeTruthy", referee);
        expect.wrapAssertion("refute", "toBeFalsy", referee);
      };
      module.exports = expect;
    }
  });

  // lib/create-expect.js
  var require_create_expect = __commonJS({
    "lib/create-expect.js"(exports, module) {
      "use strict";
      var expectImpl = require_expect();
      function createExpect(referee) {
        function expect() {
          expectImpl.init(referee);
          return expectImpl.apply(referee, arguments);
        }
        return expect;
      }
      module.exports = createExpect;
    }
  });

  // lib/create-fail.js
  var require_create_fail = __commonJS({
    "lib/create-fail.js"(exports, module) {
      "use strict";
      function createFail(referee) {
        function fail(message, errorProperties) {
          var exception = new Error(message);
          exception.name = "AssertionError";
          exception.code = "ERR_ASSERTION";
          if (errorProperties) {
            Object.keys(errorProperties).forEach(function(key) {
              exception[key] = errorProperties[key];
            });
          }
          try {
            throw exception;
          } catch (e) {
            referee.emit("failure", e);
          }
          if (typeof referee.throwOnFailure !== "boolean" || referee.throwOnFailure) {
            throw exception;
          }
        }
        return fail;
      }
      module.exports = createFail;
    }
  });

  // lib/create-pass.js
  var require_create_pass = __commonJS({
    "lib/create-pass.js"(exports, module) {
      "use strict";
      function createPass(referee) {
        function pass(message) {
          referee.emit.apply(referee, message);
        }
        return pass;
      }
      module.exports = createPass;
    }
  });

  // lib/create-verifier.js
  var require_create_verifier = __commonJS({
    "lib/create-verifier.js"(exports, module) {
      "use strict";
      function createVerifier(referee) {
        function verifier() {
          var count = 0;
          function incrementCount() {
            count += 1;
          }
          referee.on("pass", incrementCount);
          referee.on("failure", incrementCount);
          function verify(expected) {
            referee.off("pass", incrementCount);
            referee.off("failure", incrementCount);
            if (typeof expected !== "undefined" && (typeof expected !== "number" || expected < 1)) {
              throw new TypeError("expected argument must be a number >= 1");
            }
            if (expected && count !== expected) {
              throw new Error(
                `Expected assertion count to be ${expected} but was ${count}`
              );
            }
            if (count === 0) {
              throw new Error("Expected assertion count to be at least 1, but was 0");
            }
          }
          Object.defineProperty(verify, "count", {
            get: function() {
              return count;
            }
          });
          return verify;
        }
        return verifier;
      }
      module.exports = createVerifier;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-nan.js
  var require_is_nan = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-nan.js"(exports, module) {
      "use strict";
      function isNaN2(value) {
        return typeof value === "number" && value !== value;
      }
      module.exports = isNaN2;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-neg-zero.js
  var require_is_neg_zero = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-neg-zero.js"(exports, module) {
      "use strict";
      function isNegZero(value) {
        return value === 0 && 1 / value === -Infinity;
      }
      module.exports = isNegZero;
    }
  });

  // node_modules/@sinonjs/samsam/lib/identical.js
  var require_identical = __commonJS({
    "node_modules/@sinonjs/samsam/lib/identical.js"(exports, module) {
      "use strict";
      var isNaN2 = require_is_nan();
      var isNegZero = require_is_neg_zero();
      function identical(obj1, obj2) {
        if (obj1 === obj2 || isNaN2(obj1) && isNaN2(obj2)) {
          return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
        }
        return false;
      }
      module.exports = identical;
    }
  });

  // node_modules/@sinonjs/samsam/lib/get-class.js
  var require_get_class = __commonJS({
    "node_modules/@sinonjs/samsam/lib/get-class.js"(exports, module) {
      "use strict";
      var toString = require_lib().prototypes.object.toString;
      function getClass(value) {
        return toString(value).split(/[ \]]/)[1];
      }
      module.exports = getClass;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-arguments.js
  var require_is_arguments2 = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-arguments.js"(exports, module) {
      "use strict";
      var getClass = require_get_class();
      function isArguments(object) {
        return getClass(object) === "Arguments";
      }
      module.exports = isArguments;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-element.js
  var require_is_element = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-element.js"(exports, module) {
      "use strict";
      var div = typeof document !== "undefined" && document.createElement("div");
      function isElement(object) {
        if (!object || object.nodeType !== 1 || !div) {
          return false;
        }
        try {
          object.appendChild(div);
          object.removeChild(div);
        } catch (e) {
          return false;
        }
        return true;
      }
      module.exports = isElement;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-set.js
  var require_is_set = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-set.js"(exports, module) {
      "use strict";
      function isSet(val) {
        return typeof Set !== "undefined" && val instanceof Set || false;
      }
      module.exports = isSet;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-map.js
  var require_is_map = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-map.js"(exports, module) {
      "use strict";
      function isMap(value) {
        return typeof Map !== "undefined" && value instanceof Map;
      }
      module.exports = isMap;
    }
  });

  // node_modules/@sinonjs/samsam/lib/array-types.js
  var require_array_types = __commonJS({
    "node_modules/@sinonjs/samsam/lib/array-types.js"(exports, module) {
      "use strict";
      var ARRAY_TYPES = [
        Array,
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ];
      module.exports = ARRAY_TYPES;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-array-type.js
  var require_is_array_type = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-array-type.js"(exports, module) {
      "use strict";
      var functionName = require_lib().functionName;
      var indexOf = require_lib().prototypes.array.indexOf;
      var map = require_lib().prototypes.array.map;
      var ARRAY_TYPES = require_array_types();
      var type = require_type_detect();
      function isArrayType(object) {
        return indexOf(map(ARRAY_TYPES, functionName), type(object)) !== -1;
      }
      module.exports = isArrayType;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-date.js
  var require_is_date = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-date.js"(exports, module) {
      "use strict";
      function isDate(value) {
        return value instanceof Date;
      }
      module.exports = isDate;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-iterable.js
  var require_is_iterable = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-iterable.js"(exports, module) {
      "use strict";
      function isIterable(val) {
        if (typeof val !== "object") {
          return false;
        }
        return typeof val[Symbol.iterator] === "function";
      }
      module.exports = isIterable;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-object.js
  var require_is_object = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-object.js"(exports, module) {
      "use strict";
      function isObject(value) {
        return typeof value === "object" && value !== null && // none of these are collection objects, so we can return false
        !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Error) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String);
      }
      module.exports = isObject;
    }
  });

  // node_modules/@sinonjs/samsam/lib/is-subset.js
  var require_is_subset = __commonJS({
    "node_modules/@sinonjs/samsam/lib/is-subset.js"(exports, module) {
      "use strict";
      var forEach = require_lib().prototypes.set.forEach;
      function isSubset(s1, s2, compare) {
        var allContained = true;
        forEach(s1, function(v1) {
          var includes = false;
          forEach(s2, function(v2) {
            if (compare(v2, v1)) {
              includes = true;
            }
          });
          allContained = allContained && includes;
        });
        return allContained;
      }
      module.exports = isSubset;
    }
  });

  // node_modules/@sinonjs/samsam/lib/deep-equal.js
  var require_deep_equal = __commonJS({
    "node_modules/@sinonjs/samsam/lib/deep-equal.js"(exports, module) {
      "use strict";
      var valueToString = require_lib().valueToString;
      var className = require_lib().className;
      var typeOf = require_lib().typeOf;
      var arrayProto = require_lib().prototypes.array;
      var objectProto = require_lib().prototypes.object;
      var mapForEach = require_lib().prototypes.map.forEach;
      var getClass = require_get_class();
      var identical = require_identical();
      var isArguments = require_is_arguments2();
      var isArrayType = require_is_array_type();
      var isDate = require_is_date();
      var isElement = require_is_element();
      var isIterable = require_is_iterable();
      var isMap = require_is_map();
      var isNaN2 = require_is_nan();
      var isObject = require_is_object();
      var isSet = require_is_set();
      var isSubset = require_is_subset();
      var concat = arrayProto.concat;
      var every = arrayProto.every;
      var push = arrayProto.push;
      var getTime = Date.prototype.getTime;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var indexOf = arrayProto.indexOf;
      var keys = Object.keys;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      function deepEqualCyclic(actual, expectation, match) {
        var actualObjects = [];
        var expectationObjects = [];
        var actualPaths = [];
        var expectationPaths = [];
        var compared = {};
        return function deepEqual(actualObj, expectationObj, actualPath, expectationPath) {
          if (match && match.isMatcher(expectationObj)) {
            if (match.isMatcher(actualObj)) {
              return actualObj === expectationObj;
            }
            return expectationObj.test(actualObj);
          }
          var actualType = typeof actualObj;
          var expectationType = typeof expectationObj;
          if (actualObj === expectationObj || isNaN2(actualObj) || isNaN2(expectationObj) || actualObj === null || expectationObj === null || actualObj === void 0 || expectationObj === void 0 || actualType !== "object" || expectationType !== "object") {
            return identical(actualObj, expectationObj);
          }
          if (isElement(actualObj) || isElement(expectationObj)) {
            return false;
          }
          var isActualDate = isDate(actualObj);
          var isExpectationDate = isDate(expectationObj);
          if (isActualDate || isExpectationDate) {
            if (!isActualDate || !isExpectationDate || getTime.call(actualObj) !== getTime.call(expectationObj)) {
              return false;
            }
          }
          if (actualObj instanceof RegExp && expectationObj instanceof RegExp) {
            if (valueToString(actualObj) !== valueToString(expectationObj)) {
              return false;
            }
          }
          if (actualObj instanceof Promise && expectationObj instanceof Promise) {
            return actualObj === expectationObj;
          }
          if (actualObj instanceof Error && expectationObj instanceof Error) {
            return actualObj === expectationObj;
          }
          var actualClass = getClass(actualObj);
          var expectationClass = getClass(expectationObj);
          var actualKeys = keys(actualObj);
          var expectationKeys = keys(expectationObj);
          var actualName = className(actualObj);
          var expectationName = className(expectationObj);
          var expectationSymbols = typeOf(getOwnPropertySymbols) === "function" ? getOwnPropertySymbols(expectationObj) : (
            /* istanbul ignore next: cannot collect coverage for engine that doesn't support Symbol */
            []
          );
          var expectationKeysAndSymbols = concat(
            expectationKeys,
            expectationSymbols
          );
          if (isArguments(actualObj) || isArguments(expectationObj)) {
            if (actualObj.length !== expectationObj.length) {
              return false;
            }
          } else {
            if (actualType !== expectationType || actualClass !== expectationClass || actualKeys.length !== expectationKeys.length || actualName && expectationName && actualName !== expectationName) {
              return false;
            }
          }
          if (isSet(actualObj) || isSet(expectationObj)) {
            if (!isSet(actualObj) || !isSet(expectationObj) || actualObj.size !== expectationObj.size) {
              return false;
            }
            return isSubset(actualObj, expectationObj, deepEqual);
          }
          if (isMap(actualObj) || isMap(expectationObj)) {
            if (!isMap(actualObj) || !isMap(expectationObj) || actualObj.size !== expectationObj.size) {
              return false;
            }
            var mapsDeeplyEqual = true;
            mapForEach(actualObj, function(value, key) {
              mapsDeeplyEqual = mapsDeeplyEqual && deepEqualCyclic(value, expectationObj.get(key));
            });
            return mapsDeeplyEqual;
          }
          if (actualObj.constructor && actualObj.constructor.name === "jQuery" && typeof actualObj.is === "function") {
            return actualObj.is(expectationObj);
          }
          var isActualNonArrayIterable = isIterable(actualObj) && !isArrayType(actualObj) && !isArguments(actualObj);
          var isExpectationNonArrayIterable = isIterable(expectationObj) && !isArrayType(expectationObj) && !isArguments(expectationObj);
          if (isActualNonArrayIterable || isExpectationNonArrayIterable) {
            var actualArray = Array.from(actualObj);
            var expectationArray = Array.from(expectationObj);
            if (actualArray.length !== expectationArray.length) {
              return false;
            }
            var arrayDeeplyEquals = true;
            every(actualArray, function(key) {
              arrayDeeplyEquals = arrayDeeplyEquals && deepEqualCyclic(actualArray[key], expectationArray[key]);
            });
            return arrayDeeplyEquals;
          }
          return every(expectationKeysAndSymbols, function(key) {
            if (!hasOwnProperty2(actualObj, key)) {
              return false;
            }
            var actualValue = actualObj[key];
            var expectationValue = expectationObj[key];
            var actualObject = isObject(actualValue);
            var expectationObject = isObject(expectationValue);
            var actualIndex = actualObject ? indexOf(actualObjects, actualValue) : -1;
            var expectationIndex = expectationObject ? indexOf(expectationObjects, expectationValue) : -1;
            var newActualPath = actualIndex !== -1 ? actualPaths[actualIndex] : `${actualPath}[${JSON.stringify(key)}]`;
            var newExpectationPath = expectationIndex !== -1 ? expectationPaths[expectationIndex] : `${expectationPath}[${JSON.stringify(key)}]`;
            var combinedPath = newActualPath + newExpectationPath;
            if (compared[combinedPath]) {
              return true;
            }
            if (actualIndex === -1 && actualObject) {
              push(actualObjects, actualValue);
              push(actualPaths, newActualPath);
            }
            if (expectationIndex === -1 && expectationObject) {
              push(expectationObjects, expectationValue);
              push(expectationPaths, newExpectationPath);
            }
            if (actualObject && expectationObject) {
              compared[combinedPath] = true;
            }
            return deepEqual(
              actualValue,
              expectationValue,
              newActualPath,
              newExpectationPath
            );
          });
        }(actual, expectation, "$1", "$2");
      }
      deepEqualCyclic.use = function(match) {
        return function deepEqual(a, b) {
          return deepEqualCyclic(a, b, match);
        };
      };
      module.exports = deepEqualCyclic;
    }
  });

  // node_modules/lodash.get/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.get/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY = 1 / 0;
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var symbolTag = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      var reLeadingDot = /^\./;
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Symbol2 = root.Symbol;
      var splice = arrayProto.splice;
      var Map2 = getNative(root, "Map");
      var nativeCreate = getNative(Object, "create");
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castPath(value) {
        return isArray(value) ? value : stringToPath(value);
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var stringToPath = memoize(function(string) {
        string = toString(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // node_modules/@sinonjs/samsam/lib/iterable-to-string.js
  var require_iterable_to_string = __commonJS({
    "node_modules/@sinonjs/samsam/lib/iterable-to-string.js"(exports, module) {
      "use strict";
      var slice = require_lib().prototypes.string.slice;
      var typeOf = require_lib().typeOf;
      var valueToString = require_lib().valueToString;
      function iterableToString(obj) {
        if (typeOf(obj) === "map") {
          return mapToString(obj);
        }
        return genericIterableToString(obj);
      }
      function mapToString(map) {
        var representation = "";
        map.forEach(function(value, key) {
          representation += `[${stringify(key)},${stringify(value)}],`;
        });
        representation = slice(representation, 0, -1);
        return representation;
      }
      function genericIterableToString(iterable) {
        var representation = "";
        iterable.forEach(function(value) {
          representation += `${stringify(value)},`;
        });
        representation = slice(representation, 0, -1);
        return representation;
      }
      function stringify(item) {
        return typeof item === "string" ? `'${item}'` : valueToString(item);
      }
      module.exports = iterableToString;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/matcher-prototype.js
  var require_matcher_prototype = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/matcher-prototype.js"(exports, module) {
      "use strict";
      var matcherPrototype = {
        toString: function() {
          return this.message;
        }
      };
      matcherPrototype.or = function(valueOrMatcher) {
        var createMatcher = require_create_matcher();
        var isMatcher = createMatcher.isMatcher;
        if (!arguments.length) {
          throw new TypeError("Matcher expected");
        }
        var m2 = isMatcher(valueOrMatcher) ? valueOrMatcher : createMatcher(valueOrMatcher);
        var m1 = this;
        var or = Object.create(matcherPrototype);
        or.test = function(actual) {
          return m1.test(actual) || m2.test(actual);
        };
        or.message = `${m1.message}.or(${m2.message})`;
        return or;
      };
      matcherPrototype.and = function(valueOrMatcher) {
        var createMatcher = require_create_matcher();
        var isMatcher = createMatcher.isMatcher;
        if (!arguments.length) {
          throw new TypeError("Matcher expected");
        }
        var m2 = isMatcher(valueOrMatcher) ? valueOrMatcher : createMatcher(valueOrMatcher);
        var m1 = this;
        var and = Object.create(matcherPrototype);
        and.test = function(actual) {
          return m1.test(actual) && m2.test(actual);
        };
        and.message = `${m1.message}.and(${m2.message})`;
        return and;
      };
      module.exports = matcherPrototype;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/is-matcher.js
  var require_is_matcher = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/is-matcher.js"(exports, module) {
      "use strict";
      var isPrototypeOf = require_lib().prototypes.object.isPrototypeOf;
      var matcherPrototype = require_matcher_prototype();
      function isMatcher(object) {
        return isPrototypeOf(matcherPrototype, object);
      }
      module.exports = isMatcher;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/assert-matcher.js
  var require_assert_matcher = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/assert-matcher.js"(exports, module) {
      "use strict";
      var isMatcher = require_is_matcher();
      function assertMatcher(value) {
        if (!isMatcher(value)) {
          throw new TypeError("Matcher expected");
        }
      }
      module.exports = assertMatcher;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/assert-method-exists.js
  var require_assert_method_exists = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/assert-method-exists.js"(exports, module) {
      "use strict";
      function assertMethodExists(value, method, name, methodPath) {
        if (value[method] === null || value[method] === void 0) {
          throw new TypeError(`Expected ${name} to have method ${methodPath}`);
        }
      }
      module.exports = assertMethodExists;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/assert-type.js
  var require_assert_type = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/assert-type.js"(exports, module) {
      "use strict";
      var typeOf = require_lib().typeOf;
      function assertType(value, type, name) {
        var actual = typeOf(value);
        if (actual !== type) {
          throw new TypeError(
            `Expected type of ${name} to be ${type}, but was ${actual}`
          );
        }
      }
      module.exports = assertType;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/is-iterable.js
  var require_is_iterable2 = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/is-iterable.js"(exports, module) {
      "use strict";
      var typeOf = require_lib().typeOf;
      function isIterable(value) {
        return Boolean(value) && typeOf(value.forEach) === "function";
      }
      module.exports = isIterable;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/match-object.js
  var require_match_object = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/match-object.js"(exports, module) {
      "use strict";
      var every = require_lib().prototypes.array.every;
      var concat = require_lib().prototypes.array.concat;
      var typeOf = require_lib().typeOf;
      var deepEqualFactory = require_deep_equal().use;
      var isMatcher = require_is_matcher();
      var keys = Object.keys;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      function matchObject(actual, expectation, matcher) {
        var deepEqual = deepEqualFactory(matcher);
        if (actual === null || actual === void 0) {
          return false;
        }
        var expectedKeys = keys(expectation);
        if (typeOf(getOwnPropertySymbols) === "function") {
          expectedKeys = concat(expectedKeys, getOwnPropertySymbols(expectation));
        }
        return every(expectedKeys, function(key) {
          var exp = expectation[key];
          var act = actual[key];
          if (isMatcher(exp)) {
            if (!exp.test(act)) {
              return false;
            }
          } else if (typeOf(exp) === "object") {
            if (!matchObject(act, exp, matcher)) {
              return false;
            }
          } else if (!deepEqual(act, exp)) {
            return false;
          }
          return true;
        });
      }
      module.exports = matchObject;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/type-map.js
  var require_type_map = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher/type-map.js"(exports, module) {
      "use strict";
      var functionName = require_lib().functionName;
      var join = require_lib().prototypes.array.join;
      var map = require_lib().prototypes.array.map;
      var stringIndexOf = require_lib().prototypes.string.indexOf;
      var valueToString = require_lib().valueToString;
      var matchObject = require_match_object();
      var createTypeMap = function(match) {
        return {
          function: function(m, expectation, message) {
            m.test = expectation;
            m.message = message || `match(${functionName(expectation)})`;
          },
          number: function(m, expectation) {
            m.test = function(actual) {
              return expectation == actual;
            };
          },
          object: function(m, expectation) {
            var array = [];
            if (typeof expectation.test === "function") {
              m.test = function(actual) {
                return expectation.test(actual) === true;
              };
              m.message = `match(${functionName(expectation.test)})`;
              return m;
            }
            array = map(Object.keys(expectation), function(key) {
              return `${key}: ${valueToString(expectation[key])}`;
            });
            m.test = function(actual) {
              return matchObject(actual, expectation, match);
            };
            m.message = `match(${join(array, ", ")})`;
            return m;
          },
          regexp: function(m, expectation) {
            m.test = function(actual) {
              return typeof actual === "string" && expectation.test(actual);
            };
          },
          string: function(m, expectation) {
            m.test = function(actual) {
              return typeof actual === "string" && stringIndexOf(actual, expectation) !== -1;
            };
            m.message = `match("${expectation}")`;
          }
        };
      };
      module.exports = createTypeMap;
    }
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher.js
  var require_create_matcher = __commonJS({
    "node_modules/@sinonjs/samsam/lib/create-matcher.js"(exports, module) {
      "use strict";
      var arrayProto = require_lib().prototypes.array;
      var deepEqual = require_deep_equal().use(createMatcher);
      var every = require_lib().every;
      var functionName = require_lib().functionName;
      var get = require_lodash();
      var iterableToString = require_iterable_to_string();
      var objectProto = require_lib().prototypes.object;
      var typeOf = require_lib().typeOf;
      var valueToString = require_lib().valueToString;
      var assertMatcher = require_assert_matcher();
      var assertMethodExists = require_assert_method_exists();
      var assertType = require_assert_type();
      var isIterable = require_is_iterable2();
      var isMatcher = require_is_matcher();
      var matcherPrototype = require_matcher_prototype();
      var arrayIndexOf = arrayProto.indexOf;
      var some = arrayProto.some;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var TYPE_MAP = require_type_map()(createMatcher);
      function createMatcher(expectation, message) {
        var m = Object.create(matcherPrototype);
        var type = typeOf(expectation);
        if (message !== void 0 && typeof message !== "string") {
          throw new TypeError("Message should be a string");
        }
        if (arguments.length > 2) {
          throw new TypeError(
            `Expected 1 or 2 arguments, received ${arguments.length}`
          );
        }
        if (type in TYPE_MAP) {
          TYPE_MAP[type](m, expectation, message);
        } else {
          m.test = function(actual) {
            return deepEqual(actual, expectation);
          };
        }
        if (!m.message) {
          m.message = `match(${valueToString(expectation)})`;
        }
        Object.defineProperty(m, "message", {
          configurable: false,
          writable: false,
          value: m.message
        });
        return m;
      }
      createMatcher.isMatcher = isMatcher;
      createMatcher.any = createMatcher(function() {
        return true;
      }, "any");
      createMatcher.defined = createMatcher(function(actual) {
        return actual !== null && actual !== void 0;
      }, "defined");
      createMatcher.truthy = createMatcher(function(actual) {
        return Boolean(actual);
      }, "truthy");
      createMatcher.falsy = createMatcher(function(actual) {
        return !actual;
      }, "falsy");
      createMatcher.same = function(expectation) {
        return createMatcher(function(actual) {
          return expectation === actual;
        }, `same(${valueToString(expectation)})`);
      };
      createMatcher.in = function(arrayOfExpectations) {
        if (typeOf(arrayOfExpectations) !== "array") {
          throw new TypeError("array expected");
        }
        return createMatcher(function(actual) {
          return some(arrayOfExpectations, function(expectation) {
            return expectation === actual;
          });
        }, `in(${valueToString(arrayOfExpectations)})`);
      };
      createMatcher.typeOf = function(type) {
        assertType(type, "string", "type");
        return createMatcher(function(actual) {
          return typeOf(actual) === type;
        }, `typeOf("${type}")`);
      };
      createMatcher.instanceOf = function(type) {
        if (typeof Symbol === "undefined" || typeof Symbol.hasInstance === "undefined") {
          assertType(type, "function", "type");
        } else {
          assertMethodExists(
            type,
            Symbol.hasInstance,
            "type",
            "[Symbol.hasInstance]"
          );
        }
        return createMatcher(function(actual) {
          return actual instanceof type;
        }, `instanceOf(${functionName(type) || objectToString(type)})`);
      };
      function createPropertyMatcher(propertyTest, messagePrefix) {
        return function(property, value) {
          assertType(property, "string", "property");
          var onlyProperty = arguments.length === 1;
          var message = `${messagePrefix}("${property}"`;
          if (!onlyProperty) {
            message += `, ${valueToString(value)}`;
          }
          message += ")";
          return createMatcher(function(actual) {
            if (actual === void 0 || actual === null || !propertyTest(actual, property)) {
              return false;
            }
            return onlyProperty || deepEqual(actual[property], value);
          }, message);
        };
      }
      createMatcher.has = createPropertyMatcher(function(actual, property) {
        if (typeof actual === "object") {
          return property in actual;
        }
        return actual[property] !== void 0;
      }, "has");
      createMatcher.hasOwn = createPropertyMatcher(function(actual, property) {
        return hasOwnProperty2(actual, property);
      }, "hasOwn");
      createMatcher.hasNested = function(property, value) {
        assertType(property, "string", "property");
        var onlyProperty = arguments.length === 1;
        var message = `hasNested("${property}"`;
        if (!onlyProperty) {
          message += `, ${valueToString(value)}`;
        }
        message += ")";
        return createMatcher(function(actual) {
          if (actual === void 0 || actual === null || get(actual, property) === void 0) {
            return false;
          }
          return onlyProperty || deepEqual(get(actual, property), value);
        }, message);
      };
      var jsonParseResultTypes = {
        null: true,
        boolean: true,
        number: true,
        string: true,
        object: true,
        array: true
      };
      createMatcher.json = function(value) {
        if (!jsonParseResultTypes[typeOf(value)]) {
          throw new TypeError("Value cannot be the result of JSON.parse");
        }
        var message = `json(${JSON.stringify(value, null, "  ")})`;
        return createMatcher(function(actual) {
          var parsed;
          try {
            parsed = JSON.parse(actual);
          } catch (e) {
            return false;
          }
          return deepEqual(parsed, value);
        }, message);
      };
      createMatcher.every = function(predicate) {
        assertMatcher(predicate);
        return createMatcher(function(actual) {
          if (typeOf(actual) === "object") {
            return every(Object.keys(actual), function(key) {
              return predicate.test(actual[key]);
            });
          }
          return isIterable(actual) && every(actual, function(element) {
            return predicate.test(element);
          });
        }, `every(${predicate.message})`);
      };
      createMatcher.some = function(predicate) {
        assertMatcher(predicate);
        return createMatcher(function(actual) {
          if (typeOf(actual) === "object") {
            return !every(Object.keys(actual), function(key) {
              return !predicate.test(actual[key]);
            });
          }
          return isIterable(actual) && !every(actual, function(element) {
            return !predicate.test(element);
          });
        }, `some(${predicate.message})`);
      };
      createMatcher.array = createMatcher.typeOf("array");
      createMatcher.array.deepEquals = function(expectation) {
        return createMatcher(function(actual) {
          var sameLength = actual.length === expectation.length;
          return typeOf(actual) === "array" && sameLength && every(actual, function(element, index) {
            var expected = expectation[index];
            return typeOf(expected) === "array" && typeOf(element) === "array" ? createMatcher.array.deepEquals(expected).test(element) : deepEqual(expected, element);
          });
        }, `deepEquals([${iterableToString(expectation)}])`);
      };
      createMatcher.array.startsWith = function(expectation) {
        return createMatcher(function(actual) {
          return typeOf(actual) === "array" && every(expectation, function(expectedElement, index) {
            return actual[index] === expectedElement;
          });
        }, `startsWith([${iterableToString(expectation)}])`);
      };
      createMatcher.array.endsWith = function(expectation) {
        return createMatcher(function(actual) {
          var offset = actual.length - expectation.length;
          return typeOf(actual) === "array" && every(expectation, function(expectedElement, index) {
            return actual[offset + index] === expectedElement;
          });
        }, `endsWith([${iterableToString(expectation)}])`);
      };
      createMatcher.array.contains = function(expectation) {
        return createMatcher(function(actual) {
          return typeOf(actual) === "array" && every(expectation, function(expectedElement) {
            return arrayIndexOf(actual, expectedElement) !== -1;
          });
        }, `contains([${iterableToString(expectation)}])`);
      };
      createMatcher.map = createMatcher.typeOf("map");
      createMatcher.map.deepEquals = function mapDeepEquals(expectation) {
        return createMatcher(function(actual) {
          var sameLength = actual.size === expectation.size;
          return typeOf(actual) === "map" && sameLength && every(actual, function(element, key) {
            return expectation.has(key) && expectation.get(key) === element;
          });
        }, `deepEquals(Map[${iterableToString(expectation)}])`);
      };
      createMatcher.map.contains = function mapContains(expectation) {
        return createMatcher(function(actual) {
          return typeOf(actual) === "map" && every(expectation, function(element, key) {
            return actual.has(key) && actual.get(key) === element;
          });
        }, `contains(Map[${iterableToString(expectation)}])`);
      };
      createMatcher.set = createMatcher.typeOf("set");
      createMatcher.set.deepEquals = function setDeepEquals(expectation) {
        return createMatcher(function(actual) {
          var sameLength = actual.size === expectation.size;
          return typeOf(actual) === "set" && sameLength && every(actual, function(element) {
            return expectation.has(element);
          });
        }, `deepEquals(Set[${iterableToString(expectation)}])`);
      };
      createMatcher.set.contains = function setContains(expectation) {
        return createMatcher(function(actual) {
          return typeOf(actual) === "set" && every(expectation, function(element) {
            return actual.has(element);
          });
        }, `contains(Set[${iterableToString(expectation)}])`);
      };
      createMatcher.bool = createMatcher.typeOf("boolean");
      createMatcher.number = createMatcher.typeOf("number");
      createMatcher.string = createMatcher.typeOf("string");
      createMatcher.object = createMatcher.typeOf("object");
      createMatcher.func = createMatcher.typeOf("function");
      createMatcher.regexp = createMatcher.typeOf("regexp");
      createMatcher.date = createMatcher.typeOf("date");
      createMatcher.symbol = createMatcher.typeOf("symbol");
      module.exports = createMatcher;
    }
  });

  // node_modules/@sinonjs/samsam/lib/match.js
  var require_match = __commonJS({
    "node_modules/@sinonjs/samsam/lib/match.js"(exports, module) {
      "use strict";
      var valueToString = require_lib().valueToString;
      var indexOf = require_lib().prototypes.string.indexOf;
      var forEach = require_lib().prototypes.array.forEach;
      var type = require_type_detect();
      var engineCanCompareMaps = typeof Array.from === "function";
      var deepEqual = require_deep_equal().use(match);
      var isArrayType = require_is_array_type();
      var isSubset = require_is_subset();
      var createMatcher = require_create_matcher();
      function arrayContains(array, subset, compare) {
        if (subset.length === 0) {
          return true;
        }
        var i, l, j, k;
        for (i = 0, l = array.length; i < l; ++i) {
          if (compare(array[i], subset[0])) {
            for (j = 0, k = subset.length; j < k; ++j) {
              if (i + j >= l) {
                return false;
              }
              if (!compare(array[i + j], subset[j])) {
                return false;
              }
            }
            return true;
          }
        }
        return false;
      }
      function match(object, matcherOrValue) {
        if (matcherOrValue && typeof matcherOrValue.test === "function") {
          return matcherOrValue.test(object);
        }
        switch (type(matcherOrValue)) {
          case "bigint":
          case "boolean":
          case "number":
          case "symbol":
            return matcherOrValue === object;
          case "function":
            return matcherOrValue(object) === true;
          case "string":
            var notNull = typeof object === "string" || Boolean(object);
            return notNull && indexOf(
              valueToString(object).toLowerCase(),
              matcherOrValue.toLowerCase()
            ) >= 0;
          case "null":
            return object === null;
          case "undefined":
            return typeof object === "undefined";
          case "Date":
            if (type(object) === "Date") {
              return object.getTime() === matcherOrValue.getTime();
            }
            break;
          case "Array":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
            return isArrayType(matcherOrValue) && arrayContains(object, matcherOrValue, match);
          case "Map":
            if (!engineCanCompareMaps) {
              throw new Error(
                "The JavaScript engine does not support Array.from and cannot reliably do value comparison of Map instances"
              );
            }
            return type(object) === "Map" && arrayContains(
              Array.from(object),
              Array.from(matcherOrValue),
              match
            );
          default:
            break;
        }
        switch (type(object)) {
          case "null":
            return false;
          case "Set":
            return isSubset(matcherOrValue, object, match);
          default:
            break;
        }
        if (matcherOrValue && typeof matcherOrValue === "object") {
          if (matcherOrValue === object) {
            return true;
          }
          if (typeof object !== "object") {
            return false;
          }
          var prop;
          for (prop in matcherOrValue) {
            var value = object[prop];
            if (typeof value === "undefined" && typeof object.getAttribute === "function") {
              value = object.getAttribute(prop);
            }
            if (matcherOrValue[prop] === null || typeof matcherOrValue[prop] === "undefined") {
              if (value !== matcherOrValue[prop]) {
                return false;
              }
            } else if (typeof value === "undefined" || !deepEqual(value, matcherOrValue[prop])) {
              return false;
            }
          }
          return true;
        }
        throw new Error("Matcher was an unknown or unsupported type");
      }
      forEach(Object.keys(createMatcher), function(key) {
        match[key] = createMatcher[key];
      });
      module.exports = match;
    }
  });

  // node_modules/@sinonjs/samsam/lib/samsam.js
  var require_samsam = __commonJS({
    "node_modules/@sinonjs/samsam/lib/samsam.js"(exports, module) {
      "use strict";
      var identical = require_identical();
      var isArguments = require_is_arguments2();
      var isElement = require_is_element();
      var isNegZero = require_is_neg_zero();
      var isSet = require_is_set();
      var isMap = require_is_map();
      var match = require_match();
      var deepEqualCyclic = require_deep_equal().use(match);
      var createMatcher = require_create_matcher();
      module.exports = {
        createMatcher,
        deepEqual: deepEqualCyclic,
        identical,
        isArguments,
        isElement,
        isMap,
        isNegZero,
        isSet,
        match
      };
    }
  });

  // lib/assertions/class-name.js
  var require_class_name2 = __commonJS({
    "lib/assertions/class-name.js"(exports, module) {
      "use strict";
      var noClassNameMessage = "${customMessage}Expected object to have className property";
      module.exports = function(referee) {
        referee.add("className", {
          assert: function(element, name) {
            if (typeof element.className === "undefined") {
              return this.fail(noClassNameMessage);
            }
            var expected = typeof name === "string" ? name.split(" ") : name;
            var actual = element.className.split(" ");
            var i, l;
            for (i = 0, l = expected.length; i < l; i++) {
              if (!actual.includes(expected[i])) {
                return false;
              }
            }
            return true;
          },
          assertMessage: "${customMessage}Expected object's className to include ${expected} but was ${actual}",
          refuteMessage: "${customMessage}Expected object's className not to include ${expected}",
          expectation: "toHaveClassName",
          values: function(element, className, message) {
            return {
              actualElement: element,
              actual: element.className,
              expected: className,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/actual-and-expected-message-values.js
  var require_actual_and_expected_message_values = __commonJS({
    "lib/actual-and-expected-message-values.js"(exports, module) {
      "use strict";
      function actualAndExpectedMessageValues(actual, expected, message) {
        return {
          actual,
          expected,
          customMessage: message
        };
      }
      module.exports = actualAndExpectedMessageValues;
    }
  });

  // lib/assertions/contains.js
  var require_contains2 = __commonJS({
    "lib/assertions/contains.js"(exports, module) {
      "use strict";
      var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
      module.exports = function(referee) {
        referee.add("contains", {
          assert: function(haystack, needle) {
            return haystack.includes(needle);
          },
          assertMessage: "${customMessage}Expected ${actual} to contain ${expected}",
          refuteMessage: "${customMessage}Expected ${actual} not to contain ${expected}",
          expectation: "toContain",
          values: actualAndExpectedMessageValues
        });
      };
    }
  });

  // lib/assertions/equals.js
  var require_equals = __commonJS({
    "lib/assertions/equals.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      module.exports = function(referee) {
        referee.add("equals", {
          // Uses arguments[2] because the function's .length is used to determine
          // the minimum required number of arguments.
          assert: function(actual, expected) {
            if (typeof expected === "undefined") {
              return this.fail(
                "Expectation for equals should not be undefined. Use assert.isUndefined instead."
              );
            }
            return samsam.deepEqual(actual, expected);
          },
          assertMessage: "${customMessage}${actual} expected to be equal to ${expected}",
          refuteMessage: "${customMessage}${actual} expected not to be equal to ${expected}",
          expectation: "toEqual",
          values: function(actual, expected, message) {
            return {
              actual,
              expected,
              customMessage: message
            };
          }
        });
        referee.assert.equals.multiLineStringHeading = "${customMessage}Expected multi-line strings to be equal:\n";
      };
    }
  });

  // lib/capture-exception.js
  var require_capture_exception = __commonJS({
    "lib/capture-exception.js"(exports, module) {
      "use strict";
      function captureException(callback) {
        try {
          callback();
        } catch (e) {
          return e;
        }
        return null;
      }
      module.exports = captureException;
    }
  });

  // lib/assertions/exception.js
  var require_exception = __commonJS({
    "lib/assertions/exception.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var hasOwnProperty2 = require_lib().prototypes.object.hasOwnProperty;
      var captureException = require_capture_exception();
      var typeNoExceptionMessage = "${customMessage}Expected ${expected} but no exception was thrown";
      var typeFailMessage = "${customMessage}Expected ${expected} but threw ${actualExceptionType} (${actualExceptionMessage})\n${actualExceptionStack}";
      var matchFailMessage = "${customMessage}Expected thrown ${actualExceptionType} (${actualExceptionMessage}) to pass matcher function";
      module.exports = function(referee) {
        referee.captureException = captureException;
        referee.add("exception", {
          assert: function(callback) {
            var matcher = arguments[1];
            var customMessage = arguments[2];
            if (typeof matcher === "string") {
              customMessage = matcher;
              matcher = void 0;
            }
            this.expected = matcher;
            this.customMessage = customMessage;
            var err = captureException(callback);
            if (err) {
              this.actualExceptionType = err.name;
              this.actualExceptionMessage = err.message;
              this.actualExceptionStack = err.stack;
            }
            if (!err) {
              if (typeof matcher === "object") {
                return this.fail(typeNoExceptionMessage);
              }
              return this.fail("message");
            }
            if (typeof matcher === "object" && !samsam.match(err, matcher)) {
              var matches = false;
              var prop;
              for (prop in matcher) {
                if (hasOwnProperty2(matcher, prop)) {
                  if (!samsam.match(err[prop], matcher[prop])) {
                    return this.fail(typeFailMessage);
                  }
                  matches = true;
                }
              }
              return matches;
            }
            if (typeof matcher === "function" && matcher(err) !== true) {
              return this.fail(matchFailMessage);
            }
            return true;
          },
          refute: function(callback) {
            var err = captureException(callback);
            if (err) {
              this.customMessage = arguments[1];
              this.actualExceptionType = err.name;
              this.actualExceptionMessage = err.message;
              return false;
            }
            return true;
          },
          expectation: "toThrow",
          assertMessage: "${customMessage}Expected exception",
          refuteMessage: "${customMessage}Expected not to throw but threw ${actualExceptionType} (${actualExceptionMessage})"
        });
      };
    }
  });

  // lib/assertions/greater.js
  var require_greater = __commonJS({
    "lib/assertions/greater.js"(exports, module) {
      "use strict";
      var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
      module.exports = function(referee) {
        referee.add("greater", {
          assert: function(actual, expected) {
            return actual > expected;
          },
          assertMessage: "${customMessage}Expected ${actual} to be greater than ${expected}",
          refuteMessage: "${customMessage}Expected ${actual} to be less than or equal to ${expected}",
          expectation: "toBeGreaterThan",
          values: actualAndExpectedMessageValues
        });
      };
    }
  });

  // lib/assertions/has-arity.js
  var require_has_arity = __commonJS({
    "lib/assertions/has-arity.js"(exports, module) {
      "use strict";
      var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
      function addHasArity(referee) {
        referee.add("hasArity", {
          assert: function assert(actual, expected) {
            if (typeof actual !== "function") {
              throw new TypeError(
                'hasArity expects "actual" argument to be a Function'
              );
            }
            if (typeof expected !== "number" || expected < 0) {
              throw new TypeError(
                'hasArity expected "expected" argument to be a non-negative Number'
              );
            }
            this.arity = actual.length;
            this.name = actual.name;
            return this.arity === expected;
          },
          assertMessage: "Expected ${name} to have arity of ${1} but was ${arity}",
          refuteMessage: "Expected ${name} to not have arity of ${1}",
          expectation: "toHaveArity",
          values: actualAndExpectedMessageValues
        });
      }
      module.exports = addHasArity;
    }
  });

  // lib/assertions/has-prototype.js
  var require_has_prototype = __commonJS({
    "lib/assertions/has-prototype.js"(exports, module) {
      "use strict";
      var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
      module.exports = function(referee) {
        referee.add("hasPrototype", {
          assert: function(actual, protoObj) {
            return protoObj.isPrototypeOf(actual);
          },
          assertMessage: "${customMessage}Expected ${actual} to have ${expected} on its prototype chain",
          refuteMessage: "${customMessage}Expected ${actual} not to have ${expected} on its prototype chain",
          expectation: "toHavePrototype",
          values: actualAndExpectedMessageValues
        });
      };
    }
  });

  // lib/actual-message-values.js
  var require_actual_message_values = __commonJS({
    "lib/actual-message-values.js"(exports, module) {
      "use strict";
      function actualMessageValues(actual, message) {
        return {
          actual,
          customMessage: message
        };
      }
      module.exports = actualMessageValues;
    }
  });

  // lib/assertions/is-array.js
  var require_is_array = __commonJS({
    "lib/assertions/is-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isArray", {
          assert: function(actual) {
            return Array.isArray(actual);
          },
          assertMessage: "${customMessage}Expected ${actual} to be array",
          refuteMessage: "${customMessage}Expected ${actual} not to be array",
          expectation: "toBeArray",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-array-buffer.js
  var require_is_array_buffer = __commonJS({
    "lib/assertions/is-array-buffer.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      var toString = require_lib().prototypes.object.toString;
      module.exports = function(referee) {
        referee.add("isArrayBuffer", {
          assert: function(actual) {
            return toString(actual) === "[object ArrayBuffer]";
          },
          assertMessage: "${customMessage}Expected ${actual} to be an ArrayBuffer",
          refuteMessage: "${customMessage}Expected ${actual} not to be an ArrayBuffer",
          expectation: "toBeArrayBuffer",
          values: actualMessageValues
        });
      };
    }
  });

  // node_modules/lodash.isarguments/index.js
  var require_lodash2 = __commonJS({
    "node_modules/lodash.isarguments/index.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      function isArguments(value) {
        return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      module.exports = isArguments;
    }
  });

  // lib/assertions/is-array-like.js
  var require_is_array_like = __commonJS({
    "lib/assertions/is-array-like.js"(exports, module) {
      "use strict";
      var isArguments = require_lodash2();
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        function isArrayLike(object) {
          return Array.isArray(object) || Boolean(object) && typeof object.length === "number" && typeof object.splice === "function" || isArguments(object);
        }
        referee.add("isArrayLike", {
          assert: function(actual) {
            return isArrayLike(actual);
          },
          assertMessage: "${customMessage}Expected ${actual} to be array like",
          refuteMessage: "${customMessage}Expected ${actual} not to be array like",
          expectation: "toBeArrayLike",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-boolean.js
  var require_is_boolean = __commonJS({
    "lib/assertions/is-boolean.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isBoolean", {
          assert: function(actual) {
            return typeof actual === "boolean";
          },
          assertMessage: "${customMessage}Expected ${value} (${actual}) to be boolean",
          refuteMessage: "${customMessage}Expected ${value} not to be boolean",
          expectation: "toBeBoolean",
          values: function(actual, message) {
            return {
              value: actual,
              actual: typeof actual,
              expected: "boolean",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-data-view.js
  var require_is_data_view = __commonJS({
    "lib/assertions/is-data-view.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      var toString = require_lib().prototypes.object.toString;
      module.exports = function(referee) {
        referee.add("isDataView", {
          assert: function(actual) {
            return toString(actual) === "[object DataView]";
          },
          assertMessage: "${customMessage}Expected ${actual} to be a DataView",
          refuteMessage: "${customMessage}Expected ${actual} not to be a DataView",
          expectation: "toBeDataView",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-date.js
  var require_is_date2 = __commonJS({
    "lib/assertions/is-date.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isDate", {
          assert: function(actual) {
            return actual instanceof Date;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Date",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Date",
          expectation: "toBeDate",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-error.js
  var require_is_error = __commonJS({
    "lib/assertions/is-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isError", {
          assert: function(actual) {
            return actual instanceof Error;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Error",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Error",
          expectation: "toBeError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-eval-error.js
  var require_is_eval_error = __commonJS({
    "lib/assertions/is-eval-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isEvalError", {
          assert: function(actual) {
            return actual instanceof EvalError;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an EvalError",
          refuteMessage: "${customMessage}Expected ${actual} not to be an EvalError",
          expectation: "toBeEvalError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-false.js
  var require_is_false = __commonJS({
    "lib/assertions/is-false.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isFalse", {
          assert: function(actual) {
            return actual === false;
          },
          assertMessage: "${customMessage}Expected ${actual} to be false",
          refuteMessage: "${customMessage}Expected ${actual} to not be false",
          expectation: "toBeFalse",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-float-32-array.js
  var require_is_float_32_array = __commonJS({
    "lib/assertions/is-float-32-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isFloat32Array", {
          assert: function(actual) {
            return actual instanceof Float32Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Float32Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Float32Array",
          expectation: "toBeFloat32Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-float-64-array.js
  var require_is_float_64_array = __commonJS({
    "lib/assertions/is-float-64-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isFloat64Array", {
          assert: function(actual) {
            return actual instanceof Float64Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Float64Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Float64Array",
          expectation: "toBeFloat64Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-function.js
  var require_is_function = __commonJS({
    "lib/assertions/is-function.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isFunction", {
          assert: function(actual) {
            return typeof actual === "function";
          },
          assertMessage: "${customMessage}${value} (${actual}) expected to be function",
          refuteMessage: "${customMessage}${value} expected not to be function",
          expectation: "toBeFunction",
          values: function(actual, message) {
            return {
              value: String(actual).replace("function(", "function (").replace("\n", ""),
              actual: typeof actual,
              expected: "function",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-infinity.js
  var require_is_infinity = __commonJS({
    "lib/assertions/is-infinity.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isInfinity", {
          assert: function(actual) {
            return actual === Infinity;
          },
          assertMessage: "${customMessage}Expected ${actual} to be Infinity",
          refuteMessage: "${customMessage}Expected ${actual} not to be Infinity",
          expectation: "toBeInfinity",
          values: function(actual, message) {
            return {
              actual,
              expected: Infinity,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-int-8-array.js
  var require_is_int_8_array = __commonJS({
    "lib/assertions/is-int-8-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isInt8Array", {
          assert: function(actual) {
            return actual instanceof Int8Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Int8Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Int8Array",
          expectation: "toBeInd8Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-int-16-array.js
  var require_is_int_16_array = __commonJS({
    "lib/assertions/is-int-16-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isInt16Array", {
          assert: function(actual) {
            return actual instanceof Int16Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Int16Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Int16Array",
          expectation: "toBeInt16Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-int-32-array.js
  var require_is_int_32_array = __commonJS({
    "lib/assertions/is-int-32-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isInt32Array", {
          assert: function(actual) {
            return actual instanceof Int32Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Int32Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Int32Array",
          expectation: "toBeInt32Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-intl-collator.js
  var require_is_intl_collator = __commonJS({
    "lib/assertions/is-intl-collator.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isIntlCollator", {
          assert: function(actual) {
            return actual instanceof Intl.Collator;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Intl.Collator",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Intl.Collator",
          expectation: "toBeIntlCollator",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-intl-date-time-format.js
  var require_is_intl_date_time_format = __commonJS({
    "lib/assertions/is-intl-date-time-format.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isIntlDateTimeFormat", {
          assert: function(actual) {
            return actual instanceof Intl.DateTimeFormat;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Intl.DateTimeFormat",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Intl.DateTimeFormat",
          expectation: "toBeIntlDateTimeFormat",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-intl-number-format.js
  var require_is_intl_number_format = __commonJS({
    "lib/assertions/is-intl-number-format.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isIntlNumberFormat", {
          assert: function(actual) {
            return actual instanceof Intl.NumberFormat;
          },
          assertMessage: "${customMessage}Expected ${actual} to be an Intl.NumberFormat",
          refuteMessage: "${customMessage}Expected ${actual} not to be an Intl.NumberFormat",
          expectation: "toBeIntlNumberFormat",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-map.js
  var require_is_map2 = __commonJS({
    "lib/assertions/is-map.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isMap", {
          assert: function(actual) {
            return actual instanceof Map;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Map",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Map",
          expectation: "toBeMap",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-nan.js
  var require_is_nan2 = __commonJS({
    "lib/assertions/is-nan.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isNaN", {
          assert: function(actual) {
            return typeof actual === "number" && isNaN(actual);
          },
          assertMessage: "${customMessage}Expected ${actual} to be NaN",
          refuteMessage: "${customMessage}Expected not to be NaN",
          expectation: "toBeNaN",
          values: function(actual, message) {
            return {
              actual,
              expected: "NaN",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-null.js
  var require_is_null = __commonJS({
    "lib/assertions/is-null.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isNull", {
          assert: function(actual) {
            return actual === null;
          },
          assertMessage: "${customMessage}Expected ${actual} to be null",
          refuteMessage: "${customMessage}Expected not to be null",
          expectation: "toBeNull",
          values: function(actual, message) {
            return {
              actual,
              expected: null,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-negative-infinity.js
  var require_is_negative_infinity = __commonJS({
    "lib/assertions/is-negative-infinity.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isNegativeInfinity", {
          assert: function(actual) {
            return actual === -Infinity;
          },
          assertMessage: "${customMessage}Expected ${actual} to be -Infinity",
          refuteMessage: "${customMessage}Expected ${actual} not to be -Infinity",
          expectation: "toBeNegativeInfinity",
          values: function(actual, message) {
            return {
              actual,
              expected: -Infinity,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-number.js
  var require_is_number = __commonJS({
    "lib/assertions/is-number.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isNumber", {
          assert: function(actual) {
            return typeof actual === "number" && !isNaN(actual);
          },
          assertMessage: "${customMessage}Expected ${value} (${actual}) to be a non-NaN number",
          refuteMessage: "${customMessage}Expected ${value} to be NaN or a non-number value",
          expectation: "toBeNumber",
          values: function(actual, message) {
            return {
              value: actual,
              actual: typeof actual,
              expected: "number",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-object.js
  var require_is_object2 = __commonJS({
    "lib/assertions/is-object.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isObject", {
          assert: function(actual) {
            return typeof actual === "object" && Boolean(actual);
          },
          assertMessage: "${customMessage}${value} (${actual}) expected to be object and not null",
          refuteMessage: "${customMessage}${value} expected to be null or not an object",
          expectation: "toBeObject",
          values: function(actual, message) {
            return {
              value: actual,
              actual: typeof actual,
              expected: "object",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-promise.js
  var require_is_promise = __commonJS({
    "lib/assertions/is-promise.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isPromise", {
          assert: function(actual) {
            return actual instanceof Promise;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Promise",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Promise",
          expectation: "toBePromise",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-range-error.js
  var require_is_range_error = __commonJS({
    "lib/assertions/is-range-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isRangeError", {
          assert: function(actual) {
            return actual instanceof RangeError;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a RangeError",
          refuteMessage: "${customMessage}Expected ${actual} not to be a RangeError",
          expectation: "toBeRangeError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-reference-error.js
  var require_is_reference_error = __commonJS({
    "lib/assertions/is-reference-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isReferenceError", {
          assert: function(actual) {
            return actual instanceof ReferenceError;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a ReferenceError",
          refuteMessage: "${customMessage}Expected ${actual} not to be a ReferenceError",
          expectation: "toBeReferenceError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-reg-exp.js
  var require_is_reg_exp = __commonJS({
    "lib/assertions/is-reg-exp.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isRegExp", {
          assert: function(actual) {
            return actual instanceof RegExp;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a RegExp",
          refuteMessage: "${customMessage}Expected ${actual} not to be a RegExp",
          expectation: "toBeRegExp",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-set.js
  var require_is_set2 = __commonJS({
    "lib/assertions/is-set.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isSet", {
          assert: function(actual) {
            return actual instanceof Set;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Set",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Set",
          expectation: "toBeSet",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-string.js
  var require_is_string = __commonJS({
    "lib/assertions/is-string.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isString", {
          assert: function(actual) {
            return typeof actual === "string";
          },
          assertMessage: "${customMessage}Expected ${value} (${actual}) to be string",
          refuteMessage: "${customMessage}Expected ${value} not to be string",
          expectation: "toBeString",
          values: function(actual, message) {
            return {
              value: actual,
              actual: typeof actual,
              expected: "string",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-symbol.js
  var require_is_symbol = __commonJS({
    "lib/assertions/is-symbol.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("isSymbol", {
          assert: function(actual) {
            return typeof actual === "symbol";
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Symbol",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Symbol",
          expectation: "toBeSymbol",
          values: function(actual, message) {
            return {
              actual,
              expected: "symbol",
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/is-syntax-error.js
  var require_is_syntax_error = __commonJS({
    "lib/assertions/is-syntax-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isSyntaxError", {
          assert: function(actual) {
            return actual instanceof SyntaxError;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a SyntaxError",
          refuteMessage: "${customMessage}Expected ${actual} not to be a SyntaxError",
          expectation: "toBeSyntaxError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-true.js
  var require_is_true = __commonJS({
    "lib/assertions/is-true.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isTrue", {
          assert: function(actual) {
            return actual === true;
          },
          assertMessage: "${customMessage}Expected ${actual} to be true",
          refuteMessage: "${customMessage}Expected ${actual} to not be true",
          expectation: "toBeTrue",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-type-error.js
  var require_is_type_error = __commonJS({
    "lib/assertions/is-type-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isTypeError", {
          assert: function(actual) {
            return actual instanceof TypeError;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a TypeError",
          refuteMessage: "${customMessage}Expected ${actual} not to be a TypeError",
          expectation: "toBeTypeError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/actual-and-type-of-message-values.js
  var require_actual_and_type_of_message_values = __commonJS({
    "lib/actual-and-type-of-message-values.js"(exports, module) {
      "use strict";
      function actualAndTypeOfMessageValues(actual, message) {
        return {
          actual,
          actualType: typeof actual,
          customMessage: message
        };
      }
      module.exports = actualAndTypeOfMessageValues;
    }
  });

  // lib/assertions/is-undefined.js
  var require_is_undefined = __commonJS({
    "lib/assertions/is-undefined.js"(exports, module) {
      "use strict";
      var actualAndTypeOfMessageValues = require_actual_and_type_of_message_values();
      module.exports = function(referee) {
        referee.add("isUndefined", {
          assert: function(actual) {
            return typeof actual === "undefined";
          },
          assertMessage: "${customMessage}Expected ${actual} (${actualType}) to be undefined",
          refuteMessage: "${customMessage}Expected ${actual} (${actualType}) not to be undefined",
          expectation: "toBeUndefined",
          values: actualAndTypeOfMessageValues
        });
      };
    }
  });

  // lib/assertions/is-uri-error.js
  var require_is_uri_error = __commonJS({
    "lib/assertions/is-uri-error.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isURIError", {
          assert: function(actual) {
            return actual instanceof URIError;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a URIError",
          refuteMessage: "${customMessage}Expected ${actual} not to be a URIError",
          expectation: "toBeURIError",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-u-int-16-array.js
  var require_is_u_int_16_array = __commonJS({
    "lib/assertions/is-u-int-16-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isUint16Array", {
          assert: function(actual) {
            return actual instanceof Uint16Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Uint16Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Uint16Array",
          expectation: "toBeUint16Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-u-int-32-array.js
  var require_is_u_int_32_array = __commonJS({
    "lib/assertions/is-u-int-32-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isUint32Array", {
          assert: function(actual) {
            return actual instanceof Uint32Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Uint32Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Uint32Array",
          expectation: "toBeUint32Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-u-int-8-array.js
  var require_is_u_int_8_array = __commonJS({
    "lib/assertions/is-u-int-8-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isUint8Array", {
          assert: function(actual) {
            return actual instanceof Uint8Array;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Uint8Array",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Uint8Array",
          expectation: "toBeUint8Array",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-u-int-8-clamped-array.js
  var require_is_u_int_8_clamped_array = __commonJS({
    "lib/assertions/is-u-int-8-clamped-array.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isUint8ClampedArray", {
          assert: function(actual) {
            return actual instanceof Uint8ClampedArray;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a Uint8ClampedArray",
          refuteMessage: "${customMessage}Expected ${actual} not to be a Uint8ClampedArray",
          expectation: "toBeUint8ClampedArray",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-weak-map.js
  var require_is_weak_map = __commonJS({
    "lib/assertions/is-weak-map.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isWeakMap", {
          assert: function(actual) {
            return actual instanceof WeakMap;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a WeakMap",
          refuteMessage: "${customMessage}Expected ${actual} not to be a WeakMap",
          expectation: "toBeWeakMap",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/is-weak-set.js
  var require_is_weak_set = __commonJS({
    "lib/assertions/is-weak-set.js"(exports, module) {
      "use strict";
      var actualMessageValues = require_actual_message_values();
      module.exports = function(referee) {
        referee.add("isWeakSet", {
          assert: function(actual) {
            return actual instanceof WeakSet;
          },
          assertMessage: "${customMessage}Expected ${actual} to be a WeakSet",
          refuteMessage: "${customMessage}Expected ${actual} not to be a WeakSet",
          expectation: "toBeWeakSet",
          values: actualMessageValues
        });
      };
    }
  });

  // lib/assertions/keys.js
  var require_keys2 = __commonJS({
    "lib/assertions/keys.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        function exactKeys(object, keys) {
          var keyMap = {};
          var keyCnt = 0;
          for (var i = 0; i < keys.length; i++) {
            keyMap[keys[i]] = true;
            keyCnt += 1;
          }
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              if (!keyMap[key]) {
                return false;
              }
              keyCnt -= 1;
            }
          }
          return keyCnt === 0;
        }
        referee.add("keys", {
          assert: function(actual, keys) {
            return exactKeys(actual, keys);
          },
          assertMessage: "${customMessage}Expected ${actualObject} to have exact keys ${expected}",
          refuteMessage: "${customMessage}Expected not to have exact keys ${expected}",
          expectation: "toHaveKeys",
          values: function(actual, keys, message) {
            return {
              actualObject: actual,
              actual: Object.keys(actual),
              expected: keys,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/less.js
  var require_less = __commonJS({
    "lib/assertions/less.js"(exports, module) {
      "use strict";
      var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
      module.exports = function(referee) {
        referee.add("less", {
          assert: function(actual, expected) {
            return actual < expected;
          },
          assertMessage: "${customMessage}Expected ${actual} to be less than ${expected}",
          refuteMessage: "${customMessage}Expected ${actual} to be greater than or equal to ${expected}",
          expectation: "toBeLessThan",
          values: actualAndExpectedMessageValues
        });
      };
    }
  });

  // lib/actual-for-match.js
  var require_actual_for_match = __commonJS({
    "lib/actual-for-match.js"(exports, module) {
      "use strict";
      var toString = require_lib().prototypes.object.toString;
      function actualForMatch(actual, match) {
        if (toString(actual) === "[object Object]" && toString(match) === "[object Object]") {
          var copy = {};
          Object.keys(match).forEach(function(key) {
            copy[key] = actual[key];
          });
          return copy;
        }
        return actual;
      }
      module.exports = actualForMatch;
    }
  });

  // lib/assertions/match.js
  var require_match2 = __commonJS({
    "lib/assertions/match.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var actualForMatch = require_actual_for_match();
      module.exports = function(referee) {
        referee.add("match", {
          assert: function(actual, matcher) {
            return samsam.match(actual, matcher);
          },
          assertMessage: "${customMessage}${actual} expected to match ${expected}",
          refuteMessage: "${customMessage}${actual} expected not to match ${expected}",
          expectation: "toMatch",
          values: function(actual, matcher, message) {
            return {
              actual: actualForMatch(actual, matcher),
              expected: matcher,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/near.js
  var require_near = __commonJS({
    "lib/assertions/near.js"(exports, module) {
      "use strict";
      module.exports = function(referee) {
        referee.add("near", {
          assert: function(actual, expected, delta) {
            return Math.abs(actual - expected) <= delta;
          },
          assertMessage: "${customMessage}Expected ${actual} to be equal to ${expected} +/- ${delta}",
          refuteMessage: "${customMessage}Expected ${actual} not to be equal to ${expected} +/- ${delta}",
          expectation: "toBeNear",
          values: function(actual, expected, delta, message) {
            return {
              actual,
              expected,
              delta,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/same.js
  var require_same = __commonJS({
    "lib/assertions/same.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
      module.exports = function(referee) {
        referee.add("same", {
          assert: function(actual, expected) {
            return samsam.identical(actual, expected);
          },
          assertMessage: "${customMessage}${actual} expected to be the same object as ${expected}",
          refuteMessage: "${customMessage}${actual} expected not to be the same object as ${expected}",
          expectation: "toBe",
          values: actualAndExpectedMessageValues
        });
      };
    }
  });

  // lib/assertions/tag-name.js
  var require_tag_name = __commonJS({
    "lib/assertions/tag-name.js"(exports, module) {
      "use strict";
      var noTagNameMessage = "${customMessage}Expected ${actualElement} to have tagName property";
      module.exports = function(referee) {
        referee.add("tagName", {
          assert: function(element, tagName) {
            if (!element.tagName) {
              return this.fail(noTagNameMessage);
            }
            return tagName.toLowerCase && tagName.toLowerCase() === element.tagName.toLowerCase();
          },
          assertMessage: "${customMessage}Expected tagName to be ${expected} but was ${actual}",
          refuteMessage: "${customMessage}Expected tagName not to be ${actual}",
          expectation: "toHaveTagName",
          values: function(element, tagName, message) {
            return {
              actualElement: element,
              actual: element.tagName,
              expected: tagName,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/json.js
  var require_json = __commonJS({
    "lib/assertions/json.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var parseErrorMessage = "${customMessage}Expected ${actual} to be valid JSON";
      module.exports = function(referee) {
        referee.add("json", {
          assert: function(actual, expected) {
            var parsed;
            try {
              parsed = JSON.parse(actual);
            } catch (e) {
              return this.fail(parseErrorMessage);
            }
            return samsam.deepEqual(parsed, expected);
          },
          assertMessage: "${customMessage}Expected ${actual} to equal ${expected}",
          refuteMessage: "${customMessage}Expected ${actual} not to equal ${expected}",
          expectation: "toEqualJson",
          values: function(actual, expected, message) {
            var parsed;
            try {
              parsed = JSON.parse(actual);
            } catch (e) {
            }
            return {
              actualRaw: actual,
              actual: parsed || actual,
              expected,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/assertions/match-json.js
  var require_match_json = __commonJS({
    "lib/assertions/match-json.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var actualForMatch = require_actual_for_match();
      var parseErrorMessage = "${customMessage}Expected ${actual} to be valid JSON";
      module.exports = function(referee) {
        referee.add("matchJson", {
          assert: function(actual, matcher) {
            var parsed;
            try {
              parsed = JSON.parse(actual);
            } catch (e) {
              return this.fail(parseErrorMessage);
            }
            return samsam.match(parsed, matcher);
          },
          assertMessage: "${customMessage}Expected ${actual} to match ${expected}",
          refuteMessage: "${customMessage}Expected ${actual} not to match ${expected}",
          expectation: "toMatchJson",
          values: function(actual, matcher, message) {
            var parsed;
            try {
              parsed = JSON.parse(actual);
            } catch (e) {
            }
            parsed = actualForMatch(parsed, matcher);
            return {
              actualRaw: actual,
              actual: parsed || actual,
              expected: matcher,
              customMessage: message
            };
          }
        });
      };
    }
  });

  // lib/create-async-assertion.js
  var require_create_async_assertion = __commonJS({
    "lib/create-async-assertion.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      function createAsyncAssertion(thenFunc, catchFunc) {
        function asyncAssertion(promise) {
          var self2 = this;
          this.expected = arguments.length === 1 ? samsam.match.any : arguments[1];
          function applyCallback(callback, context) {
            return function(actual) {
              self2.actual = actual;
              try {
                callback.apply(context, [actual, self2.expected]);
              } catch (error) {
                context.reject(error.message);
              }
            };
          }
          var assertionPromise = new Promise(function(resolve, reject) {
            try {
              var context = { resolve, reject };
              promise.then(
                applyCallback(thenFunc, context),
                applyCallback(catchFunc, context)
              );
            } catch (error) {
              reject(error.message);
            }
          }).catch(function(message) {
            self2.fail(message);
          });
          return assertionPromise;
        }
        return asyncAssertion;
      }
      module.exports = createAsyncAssertion;
    }
  });

  // lib/assertions/resolves.js
  var require_resolves = __commonJS({
    "lib/assertions/resolves.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var createAsyncAssertion = require_create_async_assertion();
      var assertMessage = "${actual} is not equal to ${expected}";
      var refuteMessage = "${actual} is equal to ${expected}";
      module.exports = function(referee) {
        function catchCallback() {
          this.reject("${0} did not resolve, it rejected instead");
        }
        referee.add("resolves", {
          assert: createAsyncAssertion(function(actual, expected) {
            if (!samsam.deepEqual(actual, expected)) {
              this.reject(assertMessage);
              return;
            }
            this.resolve();
          }, catchCallback),
          refute: createAsyncAssertion(function(actual, expected) {
            if (samsam.deepEqual(actual, expected)) {
              if (expected === samsam.match.any) {
                this.reject("${0} resolved unexpectedly");
              } else {
                this.reject(refuteMessage);
              }
              return;
            }
            this.resolve();
          }, catchCallback),
          expectation: "toResolveWith",
          assertMessage,
          refuteMessage
        });
      };
    }
  });

  // lib/assertions/rejects.js
  var require_rejects = __commonJS({
    "lib/assertions/rejects.js"(exports, module) {
      "use strict";
      var samsam = require_samsam();
      var createAsyncAssertion = require_create_async_assertion();
      var assertMessage = "${actual} is not equal to ${expected}";
      var refuteMessage = "${actual} is equal to ${expected}";
      module.exports = function(referee) {
        function thenCallback() {
          this.reject("${0} did not reject, it resolved instead");
        }
        referee.add("rejects", {
          assert: createAsyncAssertion(thenCallback, function(actual, expected) {
            if (!samsam.deepEqual(actual, expected)) {
              this.reject(assertMessage);
              return;
            }
            this.resolve();
          }),
          refute: createAsyncAssertion(thenCallback, function(actual, expected) {
            if (samsam.deepEqual(actual, expected)) {
              if (expected === samsam.match.any) {
                this.reject("${0} rejected unexpectedly");
              } else {
                this.reject(refuteMessage);
              }
              return;
            }
            this.resolve();
          }),
          expectation: "toRejectWith",
          assertMessage,
          refuteMessage
        });
      };
    }
  });

  // lib/referee.js
  var require_referee = __commonJS({
    "lib/referee.js"(exports, module) {
      var ee = require_event_emitter();
      var referee = ee();
      referee.add = require_create_add()(referee);
      referee.assert = require_create_assert()(referee);
      referee.refute = require_create_refute()(referee);
      referee.expect = require_create_expect()(referee);
      referee.fail = require_create_fail()(referee);
      referee.pass = require_create_pass()(referee);
      referee.verifier = require_create_verifier()(referee);
      referee.equals = require_samsam().deepEqual;
      referee.match = require_samsam().createMatcher;
      require_class_name2()(referee);
      require_contains2()(referee);
      require_equals()(referee);
      require_exception()(referee);
      require_greater()(referee);
      require_has_arity()(referee);
      require_has_prototype()(referee);
      require_is_array()(referee);
      require_is_array_buffer()(referee);
      require_is_array_like()(referee);
      require_is_boolean()(referee);
      require_is_data_view()(referee);
      require_is_date2()(referee);
      require_is_error()(referee);
      require_is_eval_error()(referee);
      require_is_false()(referee);
      require_is_float_32_array()(referee);
      require_is_float_64_array()(referee);
      require_is_function()(referee);
      require_is_infinity()(referee);
      require_is_int_8_array()(referee);
      require_is_int_16_array()(referee);
      require_is_int_32_array()(referee);
      require_is_intl_collator()(referee);
      require_is_intl_date_time_format()(referee);
      require_is_intl_number_format()(referee);
      require_is_map2()(referee);
      require_is_nan2()(referee);
      require_is_null()(referee);
      require_is_negative_infinity()(referee);
      require_is_number()(referee);
      require_is_object2()(referee);
      require_is_promise()(referee);
      require_is_range_error()(referee);
      require_is_reference_error()(referee);
      require_is_reg_exp()(referee);
      require_is_set2()(referee);
      require_is_string()(referee);
      require_is_symbol()(referee);
      require_is_syntax_error()(referee);
      require_is_true()(referee);
      require_is_type_error()(referee);
      require_is_undefined()(referee);
      require_is_uri_error()(referee);
      require_is_u_int_16_array()(referee);
      require_is_u_int_32_array()(referee);
      require_is_u_int_8_array()(referee);
      require_is_u_int_8_clamped_array()(referee);
      require_is_weak_map()(referee);
      require_is_weak_set()(referee);
      require_keys2()(referee);
      require_less()(referee);
      require_match2()(referee);
      require_near()(referee);
      require_same()(referee);
      require_tag_name()(referee);
      require_json()(referee);
      require_match_json()(referee);
      require_resolves()(referee);
      require_rejects()(referee);
      module.exports = referee;
    }
  });
  require_referee();
})();
